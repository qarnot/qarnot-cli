<?xml version="1.0" encoding="utf-8"?>
<RuleSet Name="Default Code Analysis Rules for .Net Core projects" Description="Rules for {ProjectName}.csproj." ToolsVersion="15.0">
   <Rules AnalyzerId="Microsoft.NetCore.Analyzers" RuleNamespace="Microsoft.NetCore.Analyzers">
    <!-- 	CA1000: Do not declare static members on generic types	When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused. -->
    <!-- <Rule Id="CA1000" Action="Default" /> -->
    <!-- 	CA1001: Types that own disposable fields should be disposable	A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface. -->
    <!-- <Rule Id="CA1001" Action="Default" /> -->
    <!-- 	CA1002: Do not expose generic lists	System.Collections.Generic.List<(Of <(T>)>) is a generic collection that is designed for performance, not inheritance. Therefore, List does not contain any virtual members. The generic collections that are designed for inheritance should be exposed instead. -->
    <!-- <Rule Id="CA1002" Action="Default" /> -->
    <!-- 	CA1003: Use generic event handler instances	A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework 2.0. -->
    <!-- <Rule Id="CA1003" Action="Default" /> -->
    <!-- 	CA1004: Generic methods should provide type parameter	Inference is how the type argument of a generic method is determined by the type of argument that is passed to the method, instead of by the explicit specification of the type argument. To enable inference, the parameter signature of a generic method must include a parameter that is of the same type as the type parameter for the method. In this case, the type argument does not have to be specified. When using inference for all type parameters, the syntax for calling generic and non-generic instance methods is identical; this simplifies the usability of generic methods. -->
    <!-- <Rule Id="CA1004" Action="Default" /> -->
    <!-- 	CA1005: Avoid excessive parameters on generic types	The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents. It is usually obvious with one type parameter, as in List<T>, and in certain cases that have two type parameters, as in Dictionary<TKey, TValue>. However, if more than two type parameters exist, the difficulty becomes too great for most users. -->
    <!-- <Rule Id="CA1005" Action="Default" /> -->
    <!-- 	CA1006: Do not nest generic types in member signatures	A nested type argument is a type argument that is also a generic type. To call a member whose signature contains a nested type argument, the user must instantiate one generic type and pass this type to the constructor of a second generic type. The required procedure and syntax are complex and should be avoided. -->
    <!-- <Rule Id="CA1006" Action="Default" /> -->
    <!-- 	CA1007: Use generics where appropriate	An externally visible method contains a reference parameter of type System.Object. Use of a generic method enables all types, subject to constraints, to be passed to the method without first casting the type to the reference parameter type. -->
    <!-- <Rule Id="CA1007" Action="Default" /> -->
    <!-- 	CA1008: Enums should have zero value	The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration. -->
    <!-- <Rule Id="CA1008" Action="Default" /> -->
    <!-- 	CA1009: Declare event handlers correctly	Event handler methods take two parameters. The first is of type System.Object and is named "sender". This is the object that raised the event. The second parameter is of type System.EventArgs and is named "e". This is the data that is associated with the event. Event handler methods should not return a value; in the C# programming language, this is indicated by the return type void. -->
    <!-- <Rule Id="CA1009" Action="Default" /> -->
    <!-- 	CA1010: Collections should implement generic interface	To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types. -->
    <!-- <Rule Id="CA1010" Action="Default" /> -->
    <!-- 	CA1011: Consider passing base types as parameters	When a base type is specified as a parameter in a method declaration, any type that is derived from the base type can be passed as the corresponding argument to the method. If the additional functionality that is provided by the derived parameter type is not required, use of the base type enables wider use of the method. -->
    <!-- <Rule Id="CA1011" Action="Default" /> -->
    <!-- 	CA1012: Abstract types should not have constructors	Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed. -->
    <!-- <Rule Id="CA1012" Action="Default" /> -->
    <!-- 	CA1013: Overload operator equals on overloading add and subtract	A public or protected type implements the addition or subtraction operators without implementing the equality operator. -->
    <!-- <Rule Id="CA1013" Action="Default" /> -->
    <!-- 	CA1014: Mark assemblies with CLSCompliantAttribute	The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant. -->
    <!-- <Rule Id="CA1014" Action="Default" /> -->
    <!-- 	CA1016: Mark assemblies with AssemblyVersionAttribute	.NET uses the version number to uniquely identify an assembly and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built. -->
    <!-- <Rule Id="CA1016" Action="Default" /> -->
    <!-- 	CA1017: Mark assemblies with ComVisibleAttribute	ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients. -->
    <!-- <Rule Id="CA1017" Action="Default" /> -->
    <!-- 	CA1018: Mark attributes with AttributeUsageAttribute	When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code. -->
    <!-- <Rule Id="CA1018" Action="Default" /> -->
    <!-- 	CA1019: Define accessors for attribute arguments	Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property. -->
    <!-- <Rule Id="CA1019" Action="Default" /> -->
    <!-- 	CA1020: Avoid namespaces with few types	Make sure that each of your namespaces has a logical organization, and that a valid reason exists for putting types in a sparsely populated namespace. -->
    <!-- <Rule Id="CA1020" Action="Default" /> -->
    <!-- 	CA1021: Avoid out parameters	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between out and ref parameters is not widely understood. -->
    <!-- <Rule Id="CA1021" Action="Default" /> -->
    <!-- 	CA1023: Indexers should not be multidimensional	Indexers (that is, indexed properties) should use a single index. Multidimensional indexers can significantly reduce the usability of the library. -->
    <!-- <Rule Id="CA1023" Action="Default" /> -->
    <!-- 	CA1024: Use properties where appropriate	A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property. -->
    <!-- <Rule Id="CA1024" Action="Default" /> -->
    <!-- 	CA1025: Replace repetitive arguments with params array	Use a parameter array instead of repeated arguments when the exact number of arguments is unknown and when the variable arguments are the same type or can be passed as the same type. -->
    <!-- <Rule Id="CA1025" Action="Default" /> -->
    <!-- 	CA1026: Default parameters should not be used	Methods that use default parameters are allowed under the CLS; however, the CLS lets compilers ignore the values that are assigned to these parameters. To maintain the behavior that you want across programming languages, methods that use default parameters should be replaced by method overloads that provide the default parameters. -->
    <!-- <Rule Id="CA1026" Action="Default" /> -->
    <!-- 	CA1027: Mark enums with FlagsAttribute	An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined. -->
    <!-- <Rule Id="CA1027" Action="Default" /> -->
    <!-- 	CA1028: Enum storage should be Int32	An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios. -->
    <!-- <Rule Id="CA1028" Action="Default" /> -->
    <!-- 	CA1030: Use events where appropriate	This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly. -->
    <!-- <Rule Id="CA1030" Action="Default" /> -->
    <!-- 	CA1031: Do not catch general exception types	General exceptions should not be caught. Catch a more specific exception, or rethrow the general exception as the last statement in the catch block. -->
    <!-- <Rule Id="CA1031" Action="Default" /> -->
    <!-- 	CA1032: Implement standard exception constructors	Failure to provide the full set of constructors can make it difficult to correctly handle exceptions. -->
    <!-- <Rule Id="CA1032" Action="Default" /> -->
    <!-- 	CA1033: Interface methods should be callable by child types	An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name. -->
    <!-- <Rule Id="CA1033" Action="Default" /> -->
    <!-- 	CA1034: Nested types should not be visible	A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible. -->
    <!-- <Rule Id="CA1034" Action="Default" /> -->
    <!-- 	CA1035: ICollection implementations have strongly typed members	This rule requires ICollection implementations to provide strongly typed members so that users are not required to cast arguments to the Object type when they use the functionality that is provided by the interface. This rule assumes that the type that implements ICollection does so to manage a collection of instances of a type that is stronger than Object. -->
    <!-- <Rule Id="CA1035" Action="Default" /> -->
    <!-- 	CA1036: Override methods on comparable types	A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than. -->
    <!-- <Rule Id="CA1036" Action="Default" /> -->
    <!-- 	CA1038: Enumerators should be strongly typed	This rule requires IEnumerator implementations to also provide a strongly typed version of the Current property so that users are not required to cast the return value to the strong type when they use the functionality that is provided by the interface. -->
    <!-- <Rule Id="CA1038" Action="Default" /> -->
    <!-- 	CA1039: Lists are strongly typed	This rule requires IList implementations to provide strongly typed members so that users are not required to cast arguments to the System.Object type when they use the functionality that is provided by the interface. -->
    <!-- <Rule Id="CA1039" Action="Default" /> -->
    <!-- 	CA1040: Avoid empty interfaces	Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented. -->
    <!-- <Rule Id="CA1040" Action="Default" /> -->
    <!-- 	CA1041: Provide ObsoleteAttribute message	A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member. -->
    <!-- <Rule Id="CA1041" Action="Default" /> -->
    <!-- 	CA1043: Use integral or string argument for indexers	Indexers (that is, indexed properties) should use integral or string types for the index. These types are typically used for indexing data structures and they increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time. -->
    <!-- <Rule Id="CA1043" Action="Default" /> -->
    <!-- 	CA1044: Properties should not be write only	Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness. -->
    <!-- <Rule Id="CA1044" Action="Default" /> -->
    <!-- 	CA1045: Do not pass types by reference	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Library architects who design for a general audience should not expect users to master working with out or ref parameters. -->
    <!-- <Rule Id="CA1045" Action="Default" /> -->
    <!-- 	CA1046: Do not overload operator equals on reference types	For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. -->
    <!-- <Rule Id="CA1046" Action="Default" /> -->
    <!-- 	CA1047: Do not declare protected members in sealed types	Types declare protected members so that inheriting types can access or override the member. By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called. -->
    <!-- <Rule Id="CA1047" Action="Default" /> -->
    <!-- 	CA1048: Do not declare virtual members in sealed types	Types declare methods as virtual so that inheriting types can override the implementation of the virtual method. By definition, a sealed type cannot be inherited. This makes a virtual method on a sealed type meaningless. -->
    <!-- <Rule Id="CA1048" Action="Default" /> -->
    <!-- 	CA1049: Types that own native resources should be disposable	Types that allocate unmanaged resources should implement IDisposable to enable callers to release those resources on demand and to shorten the lifetimes of the objects that hold the resources. -->
    <!-- <Rule Id="CA1049" Action="Default" /> -->
    <!-- 	CA1050: Declare types in namespaces	Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy. -->
    <!-- <Rule Id="CA1050" Action="Default" /> -->
    <!-- 	CA1051: Do not declare visible instance fields	The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties. -->
    <!-- <Rule Id="CA1051" Action="Default" /> -->
    <!-- 	CA1052: Static holder types should be sealed	A public or protected type contains only static members and is not declared by using the sealed (C# Reference) (NotInheritable) modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type. -->
    <!-- <Rule Id="CA1052" Action="Default" /> -->
    <!-- 	CA1053: Static holder types should not have constructors	A public or nested public type declares only static members and has a public or protected default constructor. The constructor is unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security. -->
    <!-- <Rule Id="CA1053" Action="Default" /> -->
    <!-- 	CA1054: URI parameters should not be strings	If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1054" Action="Default" /> -->
    <!-- 	CA1055: URI return values should not be strings	This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1055" Action="Default" /> -->
    <!-- 	CA1056: URI properties should not be strings	This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1056" Action="Default" /> -->
    <!-- 	CA1057: String URI overloads call System.Uri overloads	A type declares method overloads that differ only by the replacement of a string parameter with a System.Uri parameter. The overload that takes the string parameter does not call the overload that takes the URI parameter. -->
    <!-- <Rule Id="CA1057" Action="Default" /> -->
    <!-- 	CA1058: Types should not extend certain base types	An externally visible type extends certain base types. Use one of the alternatives. -->
    <!-- <Rule Id="CA1058" Action="Default" /> -->
    <!-- 	CA1059: Members should not expose certain concrete types	A concrete type is a type that has a complete implementation and therefore can be instantiated. To enable widespread use of the member, replace the concrete type by using the suggested interface. -->
    <!-- <Rule Id="CA1059" Action="Default" /> -->
    <!-- 	CA1060: Move P/Invokes to NativeMethods class	Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class. -->
    <!-- <Rule Id="CA1060" Action="Default" /> -->
    <!-- 	CA1061: Do not hide base class methods	A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method. -->
    <!-- <Rule Id="CA1061" Action="Default" /> -->
    <!-- 	CA1062: Validate arguments of public methods	All reference arguments that are passed to externally visible methods should be checked against null. -->
    <Rule Id="CA1062" Action="None" />
    <!-- 	CA1063: Implement IDisposable correctly	All IDisposable types should implement the Dispose pattern correctly. -->
    <!-- <Rule Id="CA1063" Action="Default" /> -->
    <!-- 	CA1064: Exceptions should be public	An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from Exception, SystemException, or ApplicationException, the external code will not have sufficient information to know what to do with the exception. -->
    <!-- <Rule Id="CA1064" Action="Default" /> -->
    <!-- 	CA1065: Do not raise exceptions in unexpected locations	A method that is not expected to throw exceptions throws an exception. -->
    <!-- <Rule Id="CA1065" Action="Default" /> -->
    <!-- 	CA1300: Specify MessageBoxOptions	To correctly display a message box for cultures that use a right-to-left reading order, the RightAlign and RtlReading members of the MessageBoxOptions enumeration must be passed to the Show method. -->
    <!-- <Rule Id="CA1300" Action="Default" /> -->
    <!-- 	CA1301: Avoid duplicate accelerators	An access key, also known as an accelerator, enables keyboard access to a control by using the ALT key. When multiple controls have duplicate access keys, the behavior of the access key is not well-defined. -->
    <!-- <Rule Id="CA1301" Action="Default" /> -->
    <!-- 	CA1302: Do not hardcode locale specific strings	The System.Environment.SpecialFolder enumeration contains members that refer to special system folders. The locations of these folders can have different values on different operating systems; the user can change some of the locations; and the locations are localized. The Environment.GetFolderPath method returns the locations that are associated with the Environment.SpecialFolder enumeration, localized and appropriate for the currently running computer. -->
    <Rule Id="CA1302" Action="None" />
    <!-- 	CA1303: Do not pass literals as localized parameters	An externally visible method passes a string literal as a parameter to a .NET constructor or method, and that string should be localizable. -->
    <Rule Id="CA1303" Action="None" />
    <!-- 	CA1304: Specify CultureInfo	A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. -->
    <Rule Id="CA1304" Action="None" />
    <!-- 	CA1305: Specify IFormatProvider	A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. -->
    <Rule Id="CA1305" Action="None" />
    <!-- 	CA1306: Set locale for data types	The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale. -->
    <!-- <Rule Id="CA1306" Action="Default" /> -->
    <!-- 	CA1307: Specify StringComparison	A string comparison operation uses a method overload that does not set a StringComparison parameter. -->
    <!-- <Rule Id="CA1307" Action="Default" /> -->
    <!-- 	CA1308: Normalize strings to uppercase	Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. -->
    <!-- <Rule Id="CA1308" Action="Default" /> -->
    <!-- 	CA1309: Use ordinal StringComparison	A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable. -->
    <!-- <Rule Id="CA1309" Action="Default" /> -->
    <!-- 	CA1400: P/Invoke entry points should exist	A public or protected method is marked by using the System.Runtime.InteropServices.DllImportAttribute attribute. Either the unmanaged library could not be located or the method could not be matched to a function in the library. -->
    <!-- <Rule Id="CA1400" Action="Default" /> -->
    <!-- 	CA1401: P/Invokes should not be visible	A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed. -->
    <!-- <Rule Id="CA1401" Action="Default" /> -->
    <!-- 	CA1402: Avoid overloads in COM visible interfaces	When overloaded methods are exposed to COM clients, only the first method overload retains its name. Subsequent overloads are uniquely renamed by appending to the name an underscore character (_) and an integer that corresponds to the order of declaration of the overload. -->
    <!-- <Rule Id="CA1402" Action="Default" /> -->
    <!-- 	CA1403: Auto layout types should not be COM visible	A COM-visible value type is marked by using the System.Runtime.InteropServices.StructLayoutAttribute attribute set to LayoutKind.Auto. The layout of these types can change between versions of .NET, which will break COM clients that expect a specific layout. -->
    <!-- <Rule Id="CA1403" Action="Default" /> -->
    <!-- 	CA1404: Call GetLastError immediately after P/Invoke	A call is made to the Marshal.GetLastWin32Error method or the equivalent Win32 GetLastError function, and the immediately previous call is not to an operating system invoke method. -->
    <!-- <Rule Id="CA1404" Action="Default" /> -->
    <!-- 	CA1405: COM visible type base types should be COM visible	A COM-visible type derives from a type that is not COM-visible. -->
    <!-- <Rule Id="CA1405" Action="Default" /> -->
    <!-- 	CA1406: Avoid Int64 arguments for Visual Basic 6 clients	Visual Basic 6 COM clients cannot access 64-bit integers. -->
    <!-- <Rule Id="CA1406" Action="Default" /> -->
    <!-- 	CA1407: Avoid static members in COM visible types	COM does not support static methods. -->
    <!-- <Rule Id="CA1407" Action="Default" /> -->
    <!-- 	CA1408: Do not use AutoDual ClassInterfaceType	Types that use a dual interface enable clients to bind to a specific interface layout. Any changes in a future version to the layout of the type or any base types will break COM clients that bind to the interface. By default, if the ClassInterfaceAttribute attribute is not specified, a dispatch-only interface is used. -->
    <!-- <Rule Id="CA1408" Action="Default" /> -->
    <!-- 	CA1409: Com visible types should be creatable	A reference type that is specifically marked as visible to COM contains a public parameterized constructor but does not contain a public default (parameterless) constructor. A type without a public default constructor is not creatable by COM clients. -->
    <!-- <Rule Id="CA1409" Action="Default" /> -->
    <!-- 	CA1410: COM registration methods should be matched	A type declares a method that is marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute but does not declare a method marked by using the System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute, or vice versa. -->
    <!-- <Rule Id="CA1410" Action="Default" /> -->
    <!-- 	CA1411: COM registration methods should not be visible	A method marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute or the System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute is externally visible. -->
    <!-- <Rule Id="CA1411" Action="Default" /> -->
    <!-- 	CA1412: Mark ComSource Interfaces as IDispatch	A type is marked by using the System.Runtime.InteropServices.ComSourceInterfacesAttribute attribute, and at least one of the specified interfaces is not marked by using the System.Runtime.InteropServices.InterfaceTypeAttribute attribute set to ComInterfaceType.InterfaceIsIDispatch. -->
    <!-- <Rule Id="CA1412" Action="Default" /> -->
    <!-- 	CA1413: Avoid non-public fields in COM visible value types	Nonpublic instance fields of COM-visible value types are visible to COM clients. Review the content of the fields for information that should not be exposed, or that will have unintended design or security effects. -->
    <!-- <Rule Id="CA1413" Action="Default" /> -->
    <!-- 	CA1414: Mark boolean P/Invoke arguments with MarshalAs	The Boolean data type has multiple representations in unmanaged code. -->
    <!-- <Rule Id="CA1414" Action="Default" /> -->
    <!-- 	CA1415: Declare P/Invokes correctly	This rule looks for operating system invoke method declarations that target Win32 functions that have a pointer to an OVERLAPPED structure parameter and the corresponding managed parameter is not a pointer to a System.Threading.NativeOverlapped structure. -->
    <!-- <Rule Id="CA1415" Action="Default" /> -->
    <!-- 	CA1500: Variable names should not match field names	An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors. -->
    <!-- <Rule Id="CA1500" Action="Default" /> -->
    <!-- 	CA1501: Avoid excessive inheritance	A type is more than four levels deep in its inheritance hierarchy. Deeply nested type hierarchies can be difficult to follow, understand, and maintain. -->
    <!-- <Rule Id="CA1501" Action="Default" /> -->
    <!-- 	CA1502: Avoid excessive complexity	This rule measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. -->
    <!-- <Rule Id="CA1502" Action="Default" /> -->
    <!-- 	CA1504: Review misleading field names	The name of an instance field starts with "s_", or the name of a static (Shared in Visual Basic) field starts with "m_". -->
    <!-- <Rule Id="CA1504" Action="Default" /> -->
    <!-- 	CA1505: Avoid unmaintainable code	A type or method has a low maintainability index value. A low maintainability index indicates that a type or method is probably difficult to maintain and would be a good candidate for redesign. -->
    <!-- <Rule Id="CA1505" Action="Default" /> -->
    <!-- 	CA1506: Avoid excessive class coupling	This rule measures class coupling by counting the number of unique type references that a type or method contains. -->
    <!-- <Rule Id="CA1506" Action="Default" /> -->
    <!-- 	CA1600: Do not use idle process priority	Do not set process priority to Idle. Processes that have System.Diagnostics.ProcessPriorityClass.Idle will occupy the CPU when it would otherwise be idle, and will therefore block standby. -->
    <!-- <Rule Id="CA1600" Action="Default" /> -->
    <!-- 	CA1601: Do not use timers that prevent power state changes	Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks. -->
    <!-- <Rule Id="CA1601" Action="Default" /> -->
    <!-- 	CA1700: Do not name enum values 'Reserved'	This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change. -->
    <!-- <Rule Id="CA1700" Action="Default" /> -->
    <!-- 	CA1701: Resource string compound words should be cased correctly	Each word in the resource string is split into tokens based on the casing. Each contiguous two-token combination is checked by the Microsoft spelling checker library. If recognized, the word produces a violation of the rule. -->
    <!-- <Rule Id="CA1701" Action="Default" /> -->
    <!-- 	CA1702: Compound words should be cased correctly	The name of an identifier contains multiple words, and at least one of the words appears to be a compound word that is not cased correctly. -->
    <!-- <Rule Id="CA1702" Action="Default" /> -->
    <!-- 	CA1703: Resource strings should be spelled correctly	A resource string contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA1703" Action="Default" /> -->
    <!-- 	CA1704: Identifiers should be spelled correctly	The name of an externally visible identifier contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA1704" Action="Default" /> -->
    <!-- 	CA1707: Identifiers should not contain underscores	By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters. -->
    <!-- <Rule Id="CA1707" Action="Default" /> -->
    <!-- 	CA1708: Identifiers should differ by more than case	Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive. -->
    <!-- <Rule Id="CA1708" Action="Default" /> -->
    <!-- 	CA1709: Identifiers should be cased correctly	By convention, parameter names use camel casing and namespace, type, and member names use Pascal casing. -->
    <!-- <Rule Id="CA1709" Action="Default" /> -->
    <!-- 	CA1710: Identifiers should have correct suffix	By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface. -->
    <!-- <Rule Id="CA1710" Action="Default" /> -->
    <!-- 	CA1711: Identifiers should not have incorrect suffix	By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes. -->
    <!-- <Rule Id="CA1711" Action="Default" /> -->
    <!-- 	CA1712: Do not prefix enum values with type name	Names of enumeration members are not prefixed by using the type name because development tools are expected to provide type information. -->
    <!-- <Rule Id="CA1712" Action="Default" /> -->
    <!-- 	CA1713: Events should not have before or after prefix	The name of an event starts with "Before" or "After". To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. -->
    <!-- <Rule Id="CA1713" Action="Default" /> -->
    <!-- 	CA1714: Flags enums should have plural names	A public enumeration has the System.FlagsAttribute attribute, and its name does not end in "s". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified. -->
    <!-- <Rule Id="CA1714" Action="Default" /> -->
    <!-- 	CA1715: Identifiers should have correct prefix	The name of an externally visible interface does not start with an uppercase "I". The name of a generic type parameter on an externally visible type or method does not start with an uppercase "T". -->
    <!-- <Rule Id="CA1715" Action="Default" /> -->
    <!-- 	CA1716: Identifiers should not match keywords	A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime. -->
    <!-- <Rule Id="CA1716" Action="Default" /> -->
    <!-- 	CA1717: Only FlagsAttribute enums should have plural names	Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time. -->
    <!-- <Rule Id="CA1717" Action="Default" /> -->
    <!-- 	CA1719: Parameter names should not match member names	A parameter name should communicate the meaning of a parameter and a member name should communicate the meaning of a member. It would be a rare design where these were the same. Naming a parameter the same as its member name is unintuitive and makes the library difficult to use. -->
    <!-- <Rule Id="CA1719" Action="Default" /> -->
    <!-- 	CA1720: Identifiers should not contain type names	The name of a parameter in an externally visible member contains a data type name, or the name of an externally visible member contains a language-specific data type name. -->
    <!-- <Rule Id="CA1720" Action="Default" /> -->
    <!-- 	CA1721: Property names should not match get methods	The name of a public or protected member starts with "Get" and otherwise matches the name of a public or protected property. "Get" methods and properties should have names that clearly distinguish their function. -->
    <!-- <Rule Id="CA1721" Action="Default" /> -->
    <!-- 	CA1722: Identifiers should not have incorrect prefix	By convention, only certain programming elements have names that begin with a specific prefix. -->
    <!-- <Rule Id="CA1722" Action="Default" /> -->
    <!-- 	CA1724: Type Names Should Not Match Namespaces	Type names should not match the names of .NET namespaces. Violating this rule can reduce the usability of the library. -->
    <!-- <Rule Id="CA1724" Action="Default" /> -->
    <!-- 	CA1725: Parameter names should match base declaration	Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method. -->
    <!-- <Rule Id="CA1725" Action="Default" /> -->
    <!-- 	CA1726: Use preferred terms	The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term "Flag" or "Flags". -->
    <!-- <Rule Id="CA1726" Action="Default" /> -->
    <!-- 	CA1800: Do not cast unnecessarily	Duplicate casts decrease performance, especially when the casts are performed in compact iteration statements. -->
    <!-- <Rule Id="CA1800" Action="Default" /> -->
    <!-- 	CA1801: Review unused parameters	A method signature includes a parameter that is not used in the method body. -->
    <!-- <Rule Id="CA1801" Action="Default" /> -->
    <!-- 	CA1802: Use Literals Where Appropriate	A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time. -->
    <!-- <Rule Id="CA1802" Action="Default" /> -->
    <!-- 	CA1804: Remove unused locals	Unused local variables and unnecessary assignments increase the size of an assembly and decrease performance. -->
    <!-- <Rule Id="CA1804" Action="Default" /> -->
    <!-- 	CA1806: Do not ignore method results	A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used. -->
    <!-- <Rule Id="CA1806" Action="Default" /> -->
    <!-- 	CA1809: Avoid excessive locals	A common performance optimization is to store a value in a processor register instead of memory, which is referred to as "enregistering the value". To increase the chance that all local variables are enregistered, limit the number of local variables to 64. -->
    <!-- <Rule Id="CA1809" Action="Default" /> -->
    <!-- 	CA1810: Initialize reference type static fields inline	When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called. Static constructor checks can decrease performance. -->
    <!-- <Rule Id="CA1810" Action="Default" /> -->
    <!-- 	CA1811: Avoid uncalled private code	A private or internal (assembly-level) member does not have callers in the assembly; it is not invoked by the common language runtime; and it is not invoked by a delegate. -->
    <!-- <Rule Id="CA1811" Action="Default" /> -->
    <!-- 	CA1812: Avoid uninstantiated internal classes	An instance of an assembly-level type is not created by code in the assembly. -->
    <!-- <Rule Id="CA1812" Action="Default" /> -->
    <!-- 	CA1813: Avoid unsealed attributes	.NET provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance. -->
    <!-- <Rule Id="CA1813" Action="Default" /> -->
    <!-- 	CA1814: Prefer jagged arrays over multidimensional	A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data. -->
    <!-- <Rule Id="CA1814" Action="Default" /> -->
    <!-- 	CA1815: Override equals and operator equals on value types	For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals. -->
    <!-- <Rule Id="CA1815" Action="Default" /> -->
    <!-- 	CA1816: Call GC.SuppressFinalize correctly	A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic). -->
    <!-- <Rule Id="CA1816" Action="Default" /> -->
    <!-- 	CA1819: Properties should not return arrays	Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property. -->
    <!-- <Rule Id="CA1819" Action="Default" /> -->
    <!-- 	CA1820: Test for empty strings using string length	Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals. -->
    <!-- <Rule Id="CA1820" Action="Default" /> -->
    <!-- 	CA1821: Remove empty finalizers	Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime. An empty finalizer incurs added overhead and delivers no benefit. -->
    <!-- <Rule Id="CA1821" Action="Default" /> -->
    <!-- 	CA1822: Mark members as static	Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code. -->
    <!-- <Rule Id="CA1822" Action="Default" /> -->
    <!-- 	CA1823: Avoid unused private fields	Private fields were detected that do not appear to be accessed in the assembly. -->
    <!-- <Rule Id="CA1823" Action="Default" /> -->
    <!-- 	CA1824: Mark assemblies with NeutralResourcesLanguageAttribute	The NeutralResourcesLanguage attribute informs the resource manager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set. -->
    <!-- <Rule Id="CA1824" Action="Default" /> -->
    <!-- 	CA1900: Value type fields should be portable	This rule checks that structures that are declared by using explicit layout will align correctly when marshaled to unmanaged code on 64-bit operating systems. -->
    <!-- <Rule Id="CA1900" Action="Default" /> -->
    <!-- 	CA1901: P/Invoke declarations should be portable	This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems. -->
    <!-- <Rule Id="CA1901" Action="Default" /> -->
    <!-- 	CA1903: Use only API from targeted framework	A member or type is using a member or type that was introduced in a service pack that was not included together with the targeted framework of the project. -->
    <!-- <Rule Id="CA1903" Action="Default" /> -->
    <!-- 	CA2000: Dispose objects before losing scope	Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope. -->
    <!-- <Rule Id="CA2000" Action="Default" /> -->
    <!-- 	CA2001: Avoid calling problematic methods	A member calls a potentially dangerous or problematic method. -->
    <!-- <Rule Id="CA2001" Action="Default" /> -->
    <!-- 	CA2002: Do not lock on objects with weak identity	An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object. -->
    <!-- <Rule Id="CA2002" Action="Default" /> -->
    <!-- 	CA2003: Do not treat fibers as threads	A managed thread is being treated as a Win32 thread. -->
    <!-- <Rule Id="CA2003" Action="Default" /> -->
    <!-- 	CA2004: Remove calls to GC.KeepAlive	If you convert to SafeHandle usage, remove all calls to GC.KeepAlive (object). In this case, classes should not have to call GC.KeepAlive. This assumes they do not have a finalizer but rely on SafeHandle to finalize the OS handle for them. -->
    <!-- <Rule Id="CA2004" Action="Default" /> -->
    <!-- 	CA2006: Use SafeHandle to encapsulate native resources	Use of IntPtr in managed code might indicate a potential security and reliability problem. All uses of IntPtr must be reviewed to determine whether use of a SafeHandle, or similar technology, is required in its place. -->
    <!-- <Rule Id="CA2006" Action="Default" /> -->
    <!-- 	CA2007: Do not directly await a Task	An asynchronous method awaits a Task directly. When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. This behavior can be costly in terms of performance and can result in a deadlock on the UI thread. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. -->
    <Rule Id="CA2007" Action="None" />
    <!-- 	CA2100: Review SQL queries for security vulnerabilities	A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method. This rule assumes that the string argument contains user input. A SQL command string that is built from user input is vulnerable to SQL injection attacks. -->
    <!-- <Rule Id="CA2100" Action="Default" /> -->
    <!-- 	CA2101: Specify marshaling for P/Invoke string arguments	A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability. -->
    <!-- <Rule Id="CA2101" Action="Default" /> -->
    <!-- 	CA2102: Catch non-CLSCompliant exceptions in general handlers	A member in an assembly that is not marked by using the RuntimeCompatibilityAttribute or is marked RuntimeCompatibility(WrapNonExceptionThrows = false) contains a catch block that handles System.Exception and does not contain an immediately following general catch block. -->
    <!-- <Rule Id="CA2102" Action="Default" /> -->
    <!-- 	CA2103: Review imperative security	A method uses imperative security and might be constructing the permission by using state information or return values that can change as long as the demand is active. Use declarative security whenever possible. -->
    <!-- <Rule Id="CA2103" Action="Default" /> -->
    <!-- 	CA2104: Do not declare read only mutable reference types	An externally visible type contains an externally visible read-only field that is a mutable reference type. A mutable type is a type whose instance data can be modified. -->
    <!-- <Rule Id="CA2104" Action="Default" /> -->
    <!-- 	CA2105: Array fields should not be read only	When you apply the read-only (ReadOnly in Visual Basic) modifier to a field that contains an array, the field cannot be changed to reference a different array. However, the elements of the array that are stored in a read-only field can be changed. -->
    <!-- <Rule Id="CA2105" Action="Default" /> -->
    <!-- 	CA2106: Secure asserts	A method asserts a permission and no security checks are performed on the caller. Asserting a security permission without performing any security checks can leave an exploitable security weakness in your code. -->
    <!-- <Rule Id="CA2106" Action="Default" /> -->
    <!-- 	CA2107: Review deny and permit only usage	The PermitOnly method and CodeAccessPermission.Deny security actions should be used only by those who have an advanced knowledge of .NET security. Code that uses these security actions should undergo a security review. -->
    <!-- <Rule Id="CA2107" Action="Default" /> -->
    <!-- 	CA2108: Review declarative security on value types	A public or protected value type is secured by Data Access or Link Demands. -->
    <!-- <Rule Id="CA2108" Action="Default" /> -->
    <!-- 	CA2109: Review visible event handlers	A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary. -->
    <!-- <Rule Id="CA2109" Action="Default" /> -->
    <!-- 	CA2111: Pointers should not be visible	A pointer is not private, internal, or read-only. Malicious code can change the value of the pointer, which potentially gives access to arbitrary locations in memory or causes application or system failures. -->
    <!-- <Rule Id="CA2111" Action="Default" /> -->
    <!-- 	CA2112: Secured types should not expose fields	A public or protected type contains public fields and is secured by Link Demands. If code has access to an instance of a type that is secured by a link demand, the code does not have to satisfy the link demand to access the fields of the type. -->
    <!-- <Rule Id="CA2112" Action="Default" /> -->
    <!-- 	CA2114: Method security should be a superset of type	A method should not have both method-level and type-level declarative security for the same action. -->
    <!-- <Rule Id="CA2114" Action="Default" /> -->
    <!-- 	CA2115: Call GC.KeepAlive when using native resources	This rule detects errors that might occur because an unmanaged resource is being finalized while it is still being used in unmanaged code. -->
    <!-- <Rule Id="CA2115" Action="Default" /> -->
    <!-- 	CA2116: APTCA methods should only call APTCA methods	When the APTCA (AllowPartiallyTrustedCallersAttribute) is present on a fully trusted assembly, and the assembly executes code in another assembly that does not allow for partially trusted callers, a security exploit is possible. -->
    <!-- <Rule Id="CA2116" Action="Default" /> -->
    <!-- 	CA2117: APTCA types should only extend APTCA base types	When the APTCA is present on a fully trusted assembly, and a type in the assembly inherits from a type that does not allow for partially trusted callers, a security exploit is possible. -->
    <!-- <Rule Id="CA2117" Action="Default" /> -->
    <!-- 	CA2118: Review SuppressUnmanagedCodeSecurityAttribute usage	SuppressUnmanagedCodeSecurityAttribute changes the default security system behavior for members that execute unmanaged code that uses COM interop or operating system invocation. This attribute is primarily used to increase performance; however, the performance gains come together with significant security risks. -->
    <!-- <Rule Id="CA2118" Action="Default" /> -->
    <!-- 	CA2119: Seal methods that satisfy private interfaces	An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly. -->
    <!-- <Rule Id="CA2119" Action="Default" /> -->
    <!-- 	CA2120: Secure serialization constructors	This type has a constructor that takes a System.Runtime.Serialization.SerializationInfo object and a System.Runtime.Serialization.StreamingContext object (the signature of the serialization constructor). This constructor is not secured by a security check, but one or more of the regular constructors in the type are secured. -->
    <!-- <Rule Id="CA2120" Action="Default" /> -->
    <!-- 	CA2121: Static constructors should be private	The system calls the static constructor before the first instance of the type is created or any static members are referenced. If a static constructor is not private, it can be called by code other than the system. Depending on the operations that are performed in the constructor, this can cause unexpected behavior. -->
    <!-- <Rule Id="CA2121" Action="Default" /> -->
    <!-- 	CA2122: Do not indirectly expose methods with link demands	A public or protected member has Link Demands and is called by a member that does not perform any security checks. A link demand checks the permissions of the immediate caller only. -->
    <!-- <Rule Id="CA2122" Action="Default" /> -->
    <!-- 	CA2123: Override link demands should be identical to base	This rule matches a method to its base method, which is either an interface or a virtual method in another type, and then compares the link demands on each. If this rule is violated, a malicious caller can bypass the link demand just by calling the unsecured method. -->
    <!-- <Rule Id="CA2123" Action="Default" /> -->
    <!-- 	CA2124: Wrap vulnerable finally clauses in outer try	A public or protected method contains a try/finally block. The finally block appears to reset the security state and is not itself enclosed in a finally block. -->
    <!-- <Rule Id="CA2124" Action="Default" /> -->
    <!-- 	CA2126: Type link demands require inheritance demands	A public unsealed type is protected by using a link demand and has an overridable method. Neither the type nor the method is protected by using an inheritance demand. -->
    <!-- <Rule Id="CA2126" Action="Default" /> -->
    <!-- 	CA2136: Members should not have conflicting transparency annotations	Critical code cannot occur in a 100 percent-transparent assembly. This rule analyzes 100 percent-transparent assemblies for any SecurityCritical annotations at the type, field, and method levels. -->
    <!-- <Rule Id="CA2127" Action="Default" /> -->
    <!-- 	CA2147: Transparent methods may not use security asserts	This rule analyzes all methods and types in an assembly that is either 100 percent-transparent or mixed transparent/critical, and flags any declarative or imperative use of Assert. -->
    <!-- <Rule Id="CA2128" Action="Default" /> -->
    <!-- 	CA2140: Transparent code must not reference security critical items	Methods that are marked by SecurityTransparentAttribute call nonpublic members that are marked as SecurityCritical. This rule analyzes all methods and types in an assembly that is mixed transparent/critical, and flags any calls from transparent code to nonpublic critical code that are not marked as SecurityTreatAsSafe. -->
    <!-- <Rule Id="CA2129" Action="Default" /> -->
    <!-- 	CA2130: Security critical constants should be transparent	Transparency enforcement is not enforced for constant values because compilers inline constant values so that no lookup is required at run time. Constant fields should be security transparent so that code reviewers do not assume that transparent code cannot access the constant. -->
    <!-- <Rule Id="CA2130" Action="Default" /> -->
    <!-- 	CA2131: Security critical types may not participate in type equivalence	A type participates in type equivalence and either the type itself, or a member or field of the type, is marked by using the SecurityCriticalAttribute attribute. This rule occurs on any critical types or types that contain critical methods or fields that are participating in type equivalence. When the CLR detects such a type, it does not load it with a TypeLoadException at run time. Typically, this rule is raised only when users implement type equivalence manually instead of in by relying on tlbimp and the compilers to do the type equivalence. -->
    <!-- <Rule Id="CA2131" Action="Default" /> -->
    <!-- 	CA2132: Default constructors must be at least as critical as base type default constructors	Types and members that have the SecurityCriticalAttribute cannot be used by Silverlight application code. Security-critical types and members can be used only by trusted code in the .NET Framework for Silverlight class library. Because a public or protected construction in a derived class must have the same or greater transparency than its base class, a class in an application cannot be derived from a class marked as SecurityCritical. -->
    <!-- <Rule Id="CA2132" Action="Default" /> -->
    <!-- 	CA2133: Delegates must bind to methods with consistent transparency	This warning is raised on a method that binds a delegate that is marked by using the SecurityCriticalAttribute to a method that is transparent or that is marked by using the SecuritySafeCriticalAttribute. The warning also is raised on a method that binds a delegate that is transparent or safe-critical to a critical method. -->
    <!-- <Rule Id="CA2133" Action="Default" /> -->
    <!-- 	CA2134: Methods must keep consistent transparency when overriding base methods	This rule is raised when a method marked by using the SecurityCriticalAttribute overrides a method that is transparent or marked by using the SecuritySafeCriticalAttribute. The rule also is raised when a method that is transparent or marked by using the SecuritySafeCriticalAttribute overrides a method that is marked by using a SecurityCriticalAttribute. The rule is applied when overriding a virtual method or implementing an interface. -->
    <!-- <Rule Id="CA2134" Action="Default" /> -->
    <!-- 	CA2135: Level 2 assemblies should not contain LinkDemands	LinkDemands are deprecated in the level 2 security rule set. Instead of using LinkDemands to enforce security at JIT compilation time, mark the methods, types, and fields by using the SecurityCriticalAttribute attribute. -->
    <!-- <Rule Id="CA2135" Action="Default" /> -->
    <!-- 	CA2136: Members should not have conflicting transparency annotations	Transparency attributes are applied from code elements of larger scope to elements of smaller scope. The transparency attributes of code elements that have larger scope take precedence over transparency attributes of code elements that are contained in the first element. For example, a class that is marked by using the SecurityCriticalAttribute attribute cannot contain a method that is marked by using the SecuritySafeCriticalAttribute attribute. -->
    <!-- <Rule Id="CA2136" Action="Default" /> -->
    <!-- 	CA2137: Transparent methods must contain only verifiable IL	A method contains unverifiable code or returns a type by reference. This rule is raised on attempts by security transparent code to execute unverifiable microsoft intermediate language (MISL). However, the rule does not contain a full IL verifier, and instead uses heuristics to catch most violations of MSIL verification. -->
    <!-- <Rule Id="CA2137" Action="Default" /> -->
    <!-- 	CA2138: Transparent methods must not call methods with the SuppressUnmanagedCodeSecurity attribute	A security transparent method calls a method that is marked by using the SuppressUnmanagedCodeSecurityAttribute attribute. -->
    <!-- <Rule Id="CA2138" Action="Default" /> -->
    <!-- 	CA2139: Transparent methods may not use the HandleProcessCorruptingExceptions attribute	This rule is raised by any method that is transparent and attempts to handle a process corrupting exception by using the HandleProcessCorruptedStateExceptionsAttribute attribute. A process corrupting exception is a CLR version 4.0 exception classification of exceptions such as AccessViolationException. The HandleProcessCorruptedStateExceptionsAttribute attribute may be used only by security critical methods, and will be ignored if it is applied to a transparent method. -->
    <!-- <Rule Id="CA2139" Action="Default" /> -->
    <!-- 	CA2140: Transparent code must not reference security critical items	A code element that is marked by using the SecurityCriticalAttribute attribute is security critical. A transparent method cannot use a security critical element. If a transparent type attempts to use a security critical type, a TypeAccessException, MethodAccessException, or FieldAccessException is raised. -->
    <!-- <Rule Id="CA2140" Action="Default" /> -->
    <!-- 	CA2141:Transparent methods must not satisfy LinkDemands	A security transparent method calls a method in an assembly that is not marked by using the APTCA, or a security transparent method satisfies a LinkDemand for a type or a method. -->
    <!-- <Rule Id="CA2141" Action="Default" /> -->
    <!-- 	CA2142: Transparent code should not be protected with LinkDemands	This rule is raised on transparent methods that require LinkDemands to access them. Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions. -->
    <!-- <Rule Id="CA2142" Action="Default" /> -->
    <!-- 	CA2143: Transparent methods should not use security demands	Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions. Security transparent code should use full demands to make security decisions and safe-critical code should not rely on transparent code to have made the full demand. -->
    <!-- <Rule Id="CA2143" Action="Default" /> -->
    <!-- 	CA2144: Transparent code should not load assemblies from byte arrays	The security review for transparent code is not as complete as the security review for critical code because transparent code cannot perform security sensitive actions. Assemblies that are loaded from a byte array might not be noticed in transparent code, and that byte array might contain critical, or more important safe-critical code, that does have to be audited. -->
    <!-- <Rule Id="CA2144" Action="Default" /> -->
    <!-- 	CA2145: Transparent methods should not be decorated with the SuppressUnmanagedCodeSecurityAttribute	Methods that are decorated by the SuppressUnmanagedCodeSecurityAttribute attribute have an implicit LinkDemand put upon any method that calls it. This LinkDemand requires that the calling code be security critical. Marking the method that uses SuppressUnmanagedCodeSecurity by using the SecurityCriticalAttribute attribute makes this requirement more obvious for callers of the method. -->
    <!-- <Rule Id="CA2145" Action="Default" /> -->
    <!-- 	CA2146: Types must be at least as critical as their base types and interfaces	This rule is raised when a derived type has a security transparency attribute that is not as critical as its base type or implemented interface. Only critical types can derive from critical base types or implement critical interfaces, and only critical or safe-critical types can derive from safe-critical base types or implement safe-critical interfaces. -->
    <!-- <Rule Id="CA2146" Action="Default" /> -->
    <!-- 	CA2147: Transparent methods may not use security asserts	Code that is marked as SecurityTransparentAttribute is not granted sufficient permissions to assert. -->
    <!-- <Rule Id="CA2147" Action="Default" /> -->
    <!-- 	CA2149: Transparent methods must not call into native code	This rule is raised on any transparent method that calls directly into native code (for example, through a P/Invoke). Violations of this rule lead to a MethodAccessException in the level 2 transparency model and a full demand for UnmanagedCode in the level 1 transparency model. -->
    <!-- <Rule Id="CA2149" Action="Default" /> -->
    <!-- 	CA2151: Fields with critical types should be security critical	To use security critical types, the code that references the type must be either security critical or security safe critical. This is true even if the reference is indirect. Therefore, having a security transparent or security safe critical field is misleading because transparent code will still be unable to access the field. -->
    <!-- <Rule Id="CA2151" Action="Default" /> -->
    <!-- 	CA2200: Rethrow to preserve stack details	An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost. -->
    <!-- <Rule Id="CA2200" Action="Default" /> -->
    <!-- 	CA2201: Do not raise reserved exception types	This makes the original error difficult to detect and debug. -->
    <!-- <Rule Id="CA2201" Action="Default" /> -->
    <!-- 	CA2202: Do not dispose objects multiple times	A method implementation contains code paths that could cause multiple calls to System.IDisposable.Dispose or a Dispose equivalent (such as a Close() method on some types) on the same object. -->
    <!-- <Rule Id="CA2202" Action="Default" /> -->
    <!-- 	CA2204: Literals should be spelled correctly	A literal string in a method body contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA2204" Action="Default" /> -->
    <!-- 	CA2205: Use managed equivalents of Win32 API	An operating system invoke method is defined and a .NET method that has the equivalent functionality is available. -->
    <!-- <Rule Id="CA2205" Action="Default" /> -->
    <!-- 	CA2207: Initialize value type static fields inline	A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor. -->
    <!-- <Rule Id="CA2207" Action="Default" /> -->
    <!-- 	CA2208: Instantiate argument exceptions correctly	A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException. -->
    <!-- <Rule Id="CA2208" Action="Default" /> -->
    <!-- 	CA2210: Assemblies should have valid strong names	The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer. -->
    <!-- <Rule Id="CA2210" Action="Default" /> -->
    <!-- 	CA2211: Non-constant fields should not be visible	Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object. -->
    <!-- <Rule Id="CA2211" Action="Default" /> -->
    <!-- 	CA2212: Do not mark serviced components with WebMethod	A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked by using System.Web.Services.WebMethodAttribute. Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the behavior of the method will be incorrect in some scenarios. -->
    <!-- <Rule Id="CA2212" Action="Default" /> -->
    <!-- 	CA2213: Disposable fields should be disposed	A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. -->
    <!-- <Rule Id="CA2213" Action="Default" /> -->
    <!-- 	CA2214: Do not call overridable methods in constructors	When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed. -->
    <!-- <Rule Id="CA2214" Action="Default" /> -->
    <!-- 	CA2215: Dispose methods should call base class dispose	If a type inherits from a disposable type, it must call the Dispose method of the base type from its own Dispose method. -->
    <!-- <Rule Id="CA2215" Action="Default" /> -->
    <!-- 	CA2216: Disposable types should declare finalizer	A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize. -->
    <!-- <Rule Id="CA2216" Action="Default" /> -->
    <!-- 	CA2217: Do not mark enums with FlagsAttribute	An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration. -->
    <!-- <Rule Id="CA2217" Action="Default" /> -->
    <!-- 	CA2218: Override GetHashCode on overriding Equals	GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code. -->
    <!-- <Rule Id="CA2218" Action="Default" /> -->
    <!-- 	CA2219: Do not raise exceptions in exception clauses	When an exception is raised in a finally or fault clause, the new exception hides the active exception. When an exception is raised in a filter clause, the run time silently catches the exception. This makes the original error difficult to detect and debug. -->
    <!-- <Rule Id="CA2219" Action="Default" /> -->
    <!-- 	CA2220: Finalizers should call base class finalizer	Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method. -->
    <!-- <Rule Id="CA2220" Action="Default" /> -->
    <!-- 	CA2221: Finalizers should be protected	Finalizers must use the family access modifier. -->
    <!-- <Rule Id="CA2221" Action="Default" /> -->
    <!-- 	CA2222: Do not decrease inherited member visibility	You should not change the access modifier for inherited members. Changing an inherited member to private does not prevent callers from accessing the base class implementation of the method. -->
    <!-- <Rule Id="CA2222" Action="Default" /> -->
    <!-- 	CA2223: Members should differ by more than return type	Although the common language runtime allows the use of return types to differentiate between otherwise identical members, this feature is not in the Common Language Specification, nor is it a common feature of .NET programming languages. -->
    <!-- <Rule Id="CA2223" Action="Default" /> -->
    <!-- 	CA2224: Override equals on overloading operator equals	A public type implements the equality operator but does not override Object.Equals. -->
    <!-- <Rule Id="CA2224" Action="Default" /> -->
    <!-- 	CA2225: Operator overloads have named alternates	An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators. -->
    <!-- <Rule Id="CA2225" Action="Default" /> -->
    <!-- 	CA2226: Operators should have symmetrical overloads	A type implements the equality or inequality operator and does not implement the opposite operator. -->
    <!-- <Rule Id="CA2226" Action="Default" /> -->
    <!-- 	CA2227: Collection properties should be read only	A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set. -->
    <!-- <Rule Id="CA2227" Action="Default" /> -->
    <!-- 	CA2228: Do not ship unreleased resource formats	Resource files that were built by using prerelease versions of .NET might not be usable by supported versions of .NET. -->
    <!-- <Rule Id="CA2228" Action="Default" /> -->
    <!-- 	CA2229: Implement serialization constructors	To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected. -->
    <!-- <Rule Id="CA2229" Action="Default" /> -->
    <!-- 	CA2230: Use params for variable arguments	A public or protected type contains a public or protected method that uses the VarArgs calling convention instead of the params keyword. -->
    <!-- <Rule Id="CA2230" Action="Default" /> -->
    <!-- 	CA2231: Overload operator equals on overriding ValueType.Equals	A value type overrides Object.Equals but does not implement the equality operator. -->
    <!-- <Rule Id="CA2231" Action="Default" /> -->
    <!-- 	CA2232: Mark Windows Forms entry points with STAThread	STAThreadAttribute indicates that the COM threading model for the application is a single-threaded apartment. This attribute must be present on the entry point of any application that uses Windows Forms; if it is omitted, the Windows components might not work correctly. -->
    <!-- <Rule Id="CA2232" Action="Default" /> -->
    <!-- 	CA2233: Operations should not overflow	You should not perform arithmetic operations without first validating the operands. This makes sure that the result of the operation is not outside the range of possible values for the data types that are involved. -->
    <!-- <Rule Id="CA2233" Action="Default" /> -->
    <!-- 	CA2234: Pass System.Uri objects instead of strings	A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter. -->
    <!-- <Rule Id="CA2234" Action="Default" /> -->
    <!-- 	CA2235: Mark all non-serializable fields	An instance field of a type that is not serializable is declared in a type that is serializable. -->
    <!-- <Rule Id="CA2235" Action="Default" /> -->
    <!-- 	CA2236: Call base class methods on ISerializable types	To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type method or constructor. -->
    <!-- <Rule Id="CA2236" Action="Default" /> -->
    <!-- 	CA2237: Mark ISerializable types with SerializableAttribute	To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface. -->
    <!-- <Rule Id="CA2237" Action="Default" /> -->
    <!-- 	CA2238: Implement serialization methods correctly	A method that handles a serialization event does not have the correct signature, return type, or visibility. -->
    <!-- <Rule Id="CA2238" Action="Default" /> -->
    <!-- 	CA2239: Provide deserialization methods for optional fields	A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods. -->
    <!-- <Rule Id="CA2239" Action="Default" /> -->
    <!-- 	CA2240: Implement ISerializable correctly	To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute. -->
    <!-- <Rule Id="CA2240" Action="Default" /> -->
    <!-- 	CA2241: Provide correct arguments to formatting methods	The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa. -->
    <!-- <Rule Id="CA2241" Action="Default" /> -->
    <!-- 	CA2242: Test for NaN correctly	This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value. -->
    <!-- <Rule Id="CA2242" Action="Default" /> -->
    <!-- 	CA2243: Attribute string literals should parse correctly	The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version. -->
    <!-- <Rule Id="CA2243" Action="Default" /> -->
    <!-- 	CA5122 P/Invoke declarations should not  -->
    <!-- <Rule Id="CA5122" Action="Default" /> -->
    <!-- 	CA1000: Do not declare static members on generic types	When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused. -->
    <!-- <Rule Id="CA1000" Action="Default" /> -->
    <!-- 	CA1001: Types that own disposable fields should be disposable	A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface. -->
    <!-- <Rule Id="CA1001" Action="Default" /> -->
    <!-- 	CA1002: Do not expose generic lists	System.Collections.Generic.List<(Of <(T>)>) is a generic collection that is designed for performance, not inheritance. Therefore, List does not contain any virtual members. The generic collections that are designed for inheritance should be exposed instead. -->
    <!-- <Rule Id="CA1002" Action="Default" /> -->
    <!-- 	CA1003: Use generic event handler instances	A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework 2.0. -->
    <!-- <Rule Id="CA1003" Action="Default" /> -->
    <!-- 	CA1004: Generic methods should provide type parameter	Inference is how the type argument of a generic method is determined by the type of argument that is passed to the method, instead of by the explicit specification of the type argument. To enable inference, the parameter signature of a generic method must include a parameter that is of the same type as the type parameter for the method. In this case, the type argument does not have to be specified. When using inference for all type parameters, the syntax for calling generic and non-generic instance methods is identical; this simplifies the usability of generic methods. -->
    <!-- <Rule Id="CA1004" Action="Default" /> -->
    <!-- 	CA1005: Avoid excessive parameters on generic types	The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents. It is usually obvious with one type parameter, as in List<T>, and in certain cases that have two type parameters, as in Dictionary<TKey, TValue>. However, if more than two type parameters exist, the difficulty becomes too great for most users. -->
    <!-- <Rule Id="CA1005" Action="Default" /> -->
    <!-- 	CA1006: Do not nest generic types in member signatures	A nested type argument is a type argument that is also a generic type. To call a member whose signature contains a nested type argument, the user must instantiate one generic type and pass this type to the constructor of a second generic type. The required procedure and syntax are complex and should be avoided. -->
    <!-- <Rule Id="CA1006" Action="Default" /> -->
    <!-- 	CA1007: Use generics where appropriate	An externally visible method contains a reference parameter of type System.Object. Use of a generic method enables all types, subject to constraints, to be passed to the method without first casting the type to the reference parameter type. -->
    <!-- <Rule Id="CA1007" Action="Default" /> -->
    <!-- 	CA1008: Enums should have zero value	The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration. -->
    <!-- <Rule Id="CA1008" Action="Default" /> -->
    <!-- 	CA1009: Declare event handlers correctly	Event handler methods take two parameters. The first is of type System.Object and is named "sender". This is the object that raised the event. The second parameter is of type System.EventArgs and is named "e". This is the data that is associated with the event. Event handler methods should not return a value; in the C# programming language, this is indicated by the return type void. -->
    <!-- <Rule Id="CA1009" Action="Default" /> -->
    <!-- 	CA1010: Collections should implement generic interface	To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types. -->
    <!-- <Rule Id="CA1010" Action="Default" /> -->
    <!-- 	CA1011: Consider passing base types as parameters	When a base type is specified as a parameter in a method declaration, any type that is derived from the base type can be passed as the corresponding argument to the method. If the additional functionality that is provided by the derived parameter type is not required, use of the base type enables wider use of the method. -->
    <!-- <Rule Id="CA1011" Action="Default" /> -->
    <!-- 	CA1012: Abstract types should not have constructors	Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed. -->
    <!-- <Rule Id="CA1012" Action="Default" /> -->
    <!-- 	CA1013: Overload operator equals on overloading add and subtract	A public or protected type implements the addition or subtraction operators without implementing the equality operator. -->
    <!-- <Rule Id="CA1013" Action="Default" /> -->
    <!-- 	CA1014: Mark assemblies with CLSCompliantAttribute	The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant. -->
    <!-- <Rule Id="CA1014" Action="Default" /> -->
    <!-- 	CA1016: Mark assemblies with AssemblyVersionAttribute	.NET uses the version number to uniquely identify an assembly and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built. -->
    <!-- <Rule Id="CA1016" Action="Default" /> -->
    <!-- 	CA1017: Mark assemblies with ComVisibleAttribute	ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients. -->
    <!-- <Rule Id="CA1017" Action="Default" /> -->
    <!-- 	CA1018: Mark attributes with AttributeUsageAttribute	When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code. -->
    <!-- <Rule Id="CA1018" Action="Default" /> -->
    <!-- 	CA1019: Define accessors for attribute arguments	Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property. -->
    <!-- <Rule Id="CA1019" Action="Default" /> -->
    <!-- 	CA1020: Avoid namespaces with few types	Make sure that each of your namespaces has a logical organization, and that a valid reason exists for putting types in a sparsely populated namespace. -->
    <!-- <Rule Id="CA1020" Action="Default" /> -->
    <!-- 	CA1021: Avoid out parameters	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between out and ref parameters is not widely understood. -->
    <!-- <Rule Id="CA1021" Action="Default" /> -->
    <!-- 	CA1023: Indexers should not be multidimensional	Indexers (that is, indexed properties) should use a single index. Multidimensional indexers can significantly reduce the usability of the library. -->
    <!-- <Rule Id="CA1023" Action="Default" /> -->
    <!-- 	CA1024: Use properties where appropriate	A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property. -->
    <!-- <Rule Id="CA1024" Action="Default" /> -->
    <!-- 	CA1025: Replace repetitive arguments with params array	Use a parameter array instead of repeated arguments when the exact number of arguments is unknown and when the variable arguments are the same type or can be passed as the same type. -->
    <!-- <Rule Id="CA1025" Action="Default" /> -->
    <!-- 	CA1026: Default parameters should not be used	Methods that use default parameters are allowed under the CLS; however, the CLS lets compilers ignore the values that are assigned to these parameters. To maintain the behavior that you want across programming languages, methods that use default parameters should be replaced by method overloads that provide the default parameters. -->
    <!-- <Rule Id="CA1026" Action="Default" /> -->
    <!-- 	CA1027: Mark enums with FlagsAttribute	An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined. -->
    <!-- <Rule Id="CA1027" Action="Default" /> -->
    <!-- 	CA1028: Enum storage should be Int32	An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios. -->
    <!-- <Rule Id="CA1028" Action="Default" /> -->
    <!-- 	CA1030: Use events where appropriate	This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly. -->
    <!-- <Rule Id="CA1030" Action="Default" /> -->
    <!-- 	CA1031: Do not catch general exception types	General exceptions should not be caught. Catch a more specific exception, or rethrow the general exception as the last statement in the catch block. -->
    <!-- <Rule Id="CA1031" Action="Default" /> -->
    <!-- 	CA1032: Implement standard exception constructors	Failure to provide the full set of constructors can make it difficult to correctly handle exceptions. -->
    <!-- <Rule Id="CA1032" Action="Default" /> -->
    <!-- 	CA1033: Interface methods should be callable by child types	An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name. -->
    <!-- <Rule Id="CA1033" Action="Default" /> -->
    <!-- 	CA1034: Nested types should not be visible	A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible. -->
    <!-- <Rule Id="CA1034" Action="Default" /> -->
    <!-- 	CA1035: ICollection implementations have strongly typed members	This rule requires ICollection implementations to provide strongly typed members so that users are not required to cast arguments to the Object type when they use the functionality that is provided by the interface. This rule assumes that the type that implements ICollection does so to manage a collection of instances of a type that is stronger than Object. -->
    <!-- <Rule Id="CA1035" Action="Default" /> -->
    <!-- 	CA1036: Override methods on comparable types	A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than. -->
    <!-- <Rule Id="CA1036" Action="Default" /> -->
    <!-- 	CA1038: Enumerators should be strongly typed	This rule requires IEnumerator implementations to also provide a strongly typed version of the Current property so that users are not required to cast the return value to the strong type when they use the functionality that is provided by the interface. -->
    <!-- <Rule Id="CA1038" Action="Default" /> -->
    <!-- 	CA1039: Lists are strongly typed	This rule requires IList implementations to provide strongly typed members so that users are not required to cast arguments to the System.Object type when they use the functionality that is provided by the interface. -->
    <!-- <Rule Id="CA1039" Action="Default" /> -->
    <!-- 	CA1040: Avoid empty interfaces	Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented. -->
    <!-- <Rule Id="CA1040" Action="Default" /> -->
    <!-- 	CA1041: Provide ObsoleteAttribute message	A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member. -->
    <!-- <Rule Id="CA1041" Action="Default" /> -->
    <!-- 	CA1043: Use integral or string argument for indexers	Indexers (that is, indexed properties) should use integral or string types for the index. These types are typically used for indexing data structures and they increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time. -->
    <!-- <Rule Id="CA1043" Action="Default" /> -->
    <!-- 	CA1044: Properties should not be write only	Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness. -->
    <!-- <Rule Id="CA1044" Action="Default" /> -->
    <!-- 	CA1045: Do not pass types by reference	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Library architects who design for a general audience should not expect users to master working with out or ref parameters. -->
    <!-- <Rule Id="CA1045" Action="Default" /> -->
    <!-- 	CA1046: Do not overload operator equals on reference types	For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. -->
    <!-- <Rule Id="CA1046" Action="Default" /> -->
    <!-- 	CA1047: Do not declare protected members in sealed types	Types declare protected members so that inheriting types can access or override the member. By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called. -->
    <!-- <Rule Id="CA1047" Action="Default" /> -->
    <!-- 	CA1048: Do not declare virtual members in sealed types	Types declare methods as virtual so that inheriting types can override the implementation of the virtual method. By definition, a sealed type cannot be inherited. This makes a virtual method on a sealed type meaningless. -->
    <!-- <Rule Id="CA1048" Action="Default" /> -->
    <!-- 	CA1049: Types that own native resources should be disposable	Types that allocate unmanaged resources should implement IDisposable to enable callers to release those resources on demand and to shorten the lifetimes of the objects that hold the resources. -->
    <!-- <Rule Id="CA1049" Action="Default" /> -->
    <!-- 	CA1050: Declare types in namespaces	Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy. -->
    <!-- <Rule Id="CA1050" Action="Default" /> -->
    <!-- 	CA1051: Do not declare visible instance fields	The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties. -->
    <!-- <Rule Id="CA1051" Action="Default" /> -->
    <!-- 	CA1052: Static holder types should be sealed	A public or protected type contains only static members and is not declared by using the sealed (C# Reference) (NotInheritable) modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type. -->
    <!-- <Rule Id="CA1052" Action="Default" /> -->
    <!-- 	CA1053: Static holder types should not have constructors	A public or nested public type declares only static members and has a public or protected default constructor. The constructor is unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security. -->
    <!-- <Rule Id="CA1053" Action="Default" /> -->
    <!-- 	CA1054: URI parameters should not be strings	If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1054" Action="Default" /> -->
    <!-- 	CA1055: URI return values should not be strings	This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1055" Action="Default" /> -->
    <!-- 	CA1056: URI properties should not be strings	This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. -->
    <!-- <Rule Id="CA1056" Action="Default" /> -->
    <!-- 	CA1057: String URI overloads call System.Uri overloads	A type declares method overloads that differ only by the replacement of a string parameter with a System.Uri parameter. The overload that takes the string parameter does not call the overload that takes the URI parameter. -->
    <!-- <Rule Id="CA1057" Action="Default" /> -->
    <!-- 	CA1058: Types should not extend certain base types	An externally visible type extends certain base types. Use one of the alternatives. -->
    <!-- <Rule Id="CA1058" Action="Default" /> -->
    <!-- 	CA1059: Members should not expose certain concrete types	A concrete type is a type that has a complete implementation and therefore can be instantiated. To enable widespread use of the member, replace the concrete type by using the suggested interface. -->
    <!-- <Rule Id="CA1059" Action="Default" /> -->
    <!-- 	CA1060: Move P/Invokes to NativeMethods class	Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class. -->
    <!-- <Rule Id="CA1060" Action="Default" /> -->
    <!-- 	CA1061: Do not hide base class methods	A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method. -->
    <!-- <Rule Id="CA1061" Action="Default" /> -->
    <!-- 	CA1062: Validate arguments of public methods	All reference arguments that are passed to externally visible methods should be checked against null. -->
    <!-- <Rule Id="CA1062" Action="Default" /> -->
    <!-- 	CA1063: Implement IDisposable correctly	All IDisposable types should implement the Dispose pattern correctly. -->
    <!-- <Rule Id="CA1063" Action="Default" /> -->
    <!-- 	CA1064: Exceptions should be public	An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from Exception, SystemException, or ApplicationException, the external code will not have sufficient information to know what to do with the exception. -->
    <!-- <Rule Id="CA1064" Action="Default" /> -->
    <!-- 	CA1065: Do not raise exceptions in unexpected locations	A method that is not expected to throw exceptions throws an exception. -->
    <!-- <Rule Id="CA1065" Action="Default" /> -->
    <!-- 	CA1300: Specify MessageBoxOptions	To correctly display a message box for cultures that use a right-to-left reading order, the RightAlign and RtlReading members of the MessageBoxOptions enumeration must be passed to the Show method. -->
    <!-- <Rule Id="CA1300" Action="Default" /> -->
    <!-- 	CA1301: Avoid duplicate accelerators	An access key, also known as an accelerator, enables keyboard access to a control by using the ALT key. When multiple controls have duplicate access keys, the behavior of the access key is not well-defined. -->
    <!-- <Rule Id="CA1301" Action="Default" /> -->
    <!-- 	CA1302: Do not hardcode locale specific strings	The System.Environment.SpecialFolder enumeration contains members that refer to special system folders. The locations of these folders can have different values on different operating systems; the user can change some of the locations; and the locations are localized. The Environment.GetFolderPath method returns the locations that are associated with the Environment.SpecialFolder enumeration, localized and appropriate for the currently running computer. -->
    <!-- <Rule Id="CA1302" Action="Default" /> -->
    <!-- 	CA1303: Do not pass literals as localized parameters	An externally visible method passes a string literal as a parameter to a .NET constructor or method, and that string should be localizable. -->
    <!-- <Rule Id="CA1303" Action="Default" /> -->
    <!-- 	CA1304: Specify CultureInfo	A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. -->
    <!-- <Rule Id="CA1304" Action="Default" /> -->
    <!-- 	CA1305: Specify IFormatProvider	A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. -->
    <!-- <Rule Id="CA1305" Action="Default" /> -->
    <!-- 	CA1306: Set locale for data types	The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale. -->
    <!-- <Rule Id="CA1306" Action="Default" /> -->
    <!-- 	CA1307: Specify StringComparison	A string comparison operation uses a method overload that does not set a StringComparison parameter. -->
    <!-- <Rule Id="CA1307" Action="Default" /> -->
    <!-- 	CA1308: Normalize strings to uppercase	Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. -->
    <!-- <Rule Id="CA1308" Action="Default" /> -->
    <!-- 	CA1309: Use ordinal StringComparison	A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable. -->
    <!-- <Rule Id="CA1309" Action="Default" /> -->
    <!-- 	CA1400: P/Invoke entry points should exist	A public or protected method is marked by using the System.Runtime.InteropServices.DllImportAttribute attribute. Either the unmanaged library could not be located or the method could not be matched to a function in the library. -->
    <!-- <Rule Id="CA1400" Action="Default" /> -->
    <!-- 	CA1401: P/Invokes should not be visible	A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed. -->
    <!-- <Rule Id="CA1401" Action="Default" /> -->
    <!-- 	CA1402: Avoid overloads in COM visible interfaces	When overloaded methods are exposed to COM clients, only the first method overload retains its name. Subsequent overloads are uniquely renamed by appending to the name an underscore character (_) and an integer that corresponds to the order of declaration of the overload. -->
    <!-- <Rule Id="CA1402" Action="Default" /> -->
    <!-- 	CA1403: Auto layout types should not be COM visible	A COM-visible value type is marked by using the System.Runtime.InteropServices.StructLayoutAttribute attribute set to LayoutKind.Auto. The layout of these types can change between versions of .NET, which will break COM clients that expect a specific layout. -->
    <!-- <Rule Id="CA1403" Action="Default" /> -->
    <!-- 	CA1404: Call GetLastError immediately after P/Invoke	A call is made to the Marshal.GetLastWin32Error method or the equivalent Win32 GetLastError function, and the immediately previous call is not to an operating system invoke method. -->
    <!-- <Rule Id="CA1404" Action="Default" /> -->
    <!-- 	CA1405: COM visible type base types should be COM visible	A COM-visible type derives from a type that is not COM-visible. -->
    <!-- <Rule Id="CA1405" Action="Default" /> -->
    <!-- 	CA1406: Avoid Int64 arguments for Visual Basic 6 clients	Visual Basic 6 COM clients cannot access 64-bit integers. -->
    <!-- <Rule Id="CA1406" Action="Default" /> -->
    <!-- 	CA1407: Avoid static members in COM visible types	COM does not support static methods. -->
    <!-- <Rule Id="CA1407" Action="Default" /> -->
    <!-- 	CA1408: Do not use AutoDual ClassInterfaceType	Types that use a dual interface enable clients to bind to a specific interface layout. Any changes in a future version to the layout of the type or any base types will break COM clients that bind to the interface. By default, if the ClassInterfaceAttribute attribute is not specified, a dispatch-only interface is used. -->
    <!-- <Rule Id="CA1408" Action="Default" /> -->
    <!-- 	CA1409: Com visible types should be creatable	A reference type that is specifically marked as visible to COM contains a public parameterized constructor but does not contain a public default (parameterless) constructor. A type without a public default constructor is not creatable by COM clients. -->
    <!-- <Rule Id="CA1409" Action="Default" /> -->
    <!-- 	CA1410: COM registration methods should be matched	A type declares a method that is marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute but does not declare a method marked by using the System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute, or vice versa. -->
    <!-- <Rule Id="CA1410" Action="Default" /> -->
    <!-- 	CA1411: COM registration methods should not be visible	A method marked by using the System.Runtime.InteropServices.ComRegisterFunctionAttribute attribute or the System.Runtime.InteropServices.ComUnregisterFunctionAttribute attribute is externally visible. -->
    <!-- <Rule Id="CA1411" Action="Default" /> -->
    <!-- 	CA1412: Mark ComSource Interfaces as IDispatch	A type is marked by using the System.Runtime.InteropServices.ComSourceInterfacesAttribute attribute, and at least one of the specified interfaces is not marked by using the System.Runtime.InteropServices.InterfaceTypeAttribute attribute set to ComInterfaceType.InterfaceIsIDispatch. -->
    <!-- <Rule Id="CA1412" Action="Default" /> -->
    <!-- 	CA1413: Avoid non-public fields in COM visible value types	Nonpublic instance fields of COM-visible value types are visible to COM clients. Review the content of the fields for information that should not be exposed, or that will have unintended design or security effects. -->
    <!-- <Rule Id="CA1413" Action="Default" /> -->
    <!-- 	CA1414: Mark boolean P/Invoke arguments with MarshalAs	The Boolean data type has multiple representations in unmanaged code. -->
    <!-- <Rule Id="CA1414" Action="Default" /> -->
    <!-- 	CA1415: Declare P/Invokes correctly	This rule looks for operating system invoke method declarations that target Win32 functions that have a pointer to an OVERLAPPED structure parameter and the corresponding managed parameter is not a pointer to a System.Threading.NativeOverlapped structure. -->
    <!-- <Rule Id="CA1415" Action="Default" /> -->
    <!-- 	CA1500: Variable names should not match field names	An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors. -->
    <!-- <Rule Id="CA1500" Action="Default" /> -->
    <!-- 	CA1501: Avoid excessive inheritance	A type is more than four levels deep in its inheritance hierarchy. Deeply nested type hierarchies can be difficult to follow, understand, and maintain. -->
    <!-- <Rule Id="CA1501" Action="Default" /> -->
    <!-- 	CA1502: Avoid excessive complexity	This rule measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. -->
    <!-- <Rule Id="CA1502" Action="Default" /> -->
    <!-- 	CA1504: Review misleading field names	The name of an instance field starts with "s_", or the name of a static (Shared in Visual Basic) field starts with "m_". -->
    <!-- <Rule Id="CA1504" Action="Default" /> -->
    <!-- 	CA1505: Avoid unmaintainable code	A type or method has a low maintainability index value. A low maintainability index indicates that a type or method is probably difficult to maintain and would be a good candidate for redesign. -->
    <!-- <Rule Id="CA1505" Action="Default" /> -->
    <!-- 	CA1506: Avoid excessive class coupling	This rule measures class coupling by counting the number of unique type references that a type or method contains. -->
    <!-- <Rule Id="CA1506" Action="Default" /> -->
    <!-- 	CA1600: Do not use idle process priority	Do not set process priority to Idle. Processes that have System.Diagnostics.ProcessPriorityClass.Idle will occupy the CPU when it would otherwise be idle, and will therefore block standby. -->
    <!-- <Rule Id="CA1600" Action="Default" /> -->
    <!-- 	CA1601: Do not use timers that prevent power state changes	Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks. -->
    <!-- <Rule Id="CA1601" Action="Default" /> -->
    <!-- 	CA1700: Do not name enum values 'Reserved'	This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change. -->
    <!-- <Rule Id="CA1700" Action="Default" /> -->
    <!-- 	CA1701: Resource string compound words should be cased correctly	Each word in the resource string is split into tokens based on the casing. Each contiguous two-token combination is checked by the Microsoft spelling checker library. If recognized, the word produces a violation of the rule. -->
    <!-- <Rule Id="CA1701" Action="Default" /> -->
    <!-- 	CA1702: Compound words should be cased correctly	The name of an identifier contains multiple words, and at least one of the words appears to be a compound word that is not cased correctly. -->
    <!-- <Rule Id="CA1702" Action="Default" /> -->
    <!-- 	CA1703: Resource strings should be spelled correctly	A resource string contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA1703" Action="Default" /> -->
    <!-- 	CA1704: Identifiers should be spelled correctly	The name of an externally visible identifier contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA1704" Action="Default" /> -->
    <!-- 	CA1707: Identifiers should not contain underscores	By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters. -->
    <!-- <Rule Id="CA1707" Action="Default" /> -->
    <!-- 	CA1708: Identifiers should differ by more than case	Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive. -->
    <!-- <Rule Id="CA1708" Action="Default" /> -->
    <!-- 	CA1709: Identifiers should be cased correctly	By convention, parameter names use camel casing and namespace, type, and member names use Pascal casing. -->
    <!-- <Rule Id="CA1709" Action="Default" /> -->
    <!-- 	CA1710: Identifiers should have correct suffix	By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface. -->
    <!-- <Rule Id="CA1710" Action="Default" /> -->
    <!-- 	CA1711: Identifiers should not have incorrect suffix	By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes. -->
    <!-- <Rule Id="CA1711" Action="Default" /> -->
    <!-- 	CA1712: Do not prefix enum values with type name	Names of enumeration members are not prefixed by using the type name because development tools are expected to provide type information. -->
    <!-- <Rule Id="CA1712" Action="Default" /> -->
    <!-- 	CA1713: Events should not have before or after prefix	The name of an event starts with "Before" or "After". To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. -->
    <!-- <Rule Id="CA1713" Action="Default" /> -->
    <!-- 	CA1714: Flags enums should have plural names	A public enumeration has the System.FlagsAttribute attribute, and its name does not end in "s". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified. -->
    <!-- <Rule Id="CA1714" Action="Default" /> -->
    <!-- 	CA1715: Identifiers should have correct prefix	The name of an externally visible interface does not start with an uppercase "I". The name of a generic type parameter on an externally visible type or method does not start with an uppercase "T". -->
    <!-- <Rule Id="CA1715" Action="Default" /> -->
    <!-- 	CA1716: Identifiers should not match keywords	A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime. -->
    <!-- <Rule Id="CA1716" Action="Default" /> -->
    <!-- 	CA1717: Only FlagsAttribute enums should have plural names	Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time. -->
    <!-- <Rule Id="CA1717" Action="Default" /> -->
    <!-- 	CA1719: Parameter names should not match member names	A parameter name should communicate the meaning of a parameter and a member name should communicate the meaning of a member. It would be a rare design where these were the same. Naming a parameter the same as its member name is unintuitive and makes the library difficult to use. -->
    <!-- <Rule Id="CA1719" Action="Default" /> -->
    <!-- 	CA1720: Identifiers should not contain type names	The name of a parameter in an externally visible member contains a data type name, or the name of an externally visible member contains a language-specific data type name. -->
    <!-- <Rule Id="CA1720" Action="Default" /> -->
    <!-- 	CA1721: Property names should not match get methods	The name of a public or protected member starts with "Get" and otherwise matches the name of a public or protected property. "Get" methods and properties should have names that clearly distinguish their function. -->
    <!-- <Rule Id="CA1721" Action="Default" /> -->
    <!-- 	CA1722: Identifiers should not have incorrect prefix	By convention, only certain programming elements have names that begin with a specific prefix. -->
    <!-- <Rule Id="CA1722" Action="Default" /> -->
    <!-- 	CA1724: Type Names Should Not Match Namespaces	Type names should not match the names of .NET namespaces. Violating this rule can reduce the usability of the library. -->
    <!-- <Rule Id="CA1724" Action="Default" /> -->
    <!-- 	CA1725: Parameter names should match base declaration	Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method. -->
    <!-- <Rule Id="CA1725" Action="Default" /> -->
    <!-- 	CA1726: Use preferred terms	The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term "Flag" or "Flags". -->
    <!-- <Rule Id="CA1726" Action="Default" /> -->
    <!-- 	CA1800: Do not cast unnecessarily	Duplicate casts decrease performance, especially when the casts are performed in compact iteration statements. -->
    <!-- <Rule Id="CA1800" Action="Default" /> -->
    <!-- 	CA1801: Review unused parameters	A method signature includes a parameter that is not used in the method body. -->
    <!-- <Rule Id="CA1801" Action="Default" /> -->
    <!-- 	CA1802: Use Literals Where Appropriate	A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time. -->
    <!-- <Rule Id="CA1802" Action="Default" /> -->
    <!-- 	CA1804: Remove unused locals	Unused local variables and unnecessary assignments increase the size of an assembly and decrease performance. -->
    <!-- <Rule Id="CA1804" Action="Default" /> -->
    <!-- 	CA1806: Do not ignore method results	A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used. -->
    <!-- <Rule Id="CA1806" Action="Default" /> -->
    <!-- 	CA1809: Avoid excessive locals	A common performance optimization is to store a value in a processor register instead of memory, which is referred to as "enregistering the value". To increase the chance that all local variables are enregistered, limit the number of local variables to 64. -->
    <!-- <Rule Id="CA1809" Action="Default" /> -->
    <!-- 	CA1810: Initialize reference type static fields inline	When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called. Static constructor checks can decrease performance. -->
    <!-- <Rule Id="CA1810" Action="Default" /> -->
    <!-- 	CA1811: Avoid uncalled private code	A private or internal (assembly-level) member does not have callers in the assembly; it is not invoked by the common language runtime; and it is not invoked by a delegate. -->
    <!-- <Rule Id="CA1811" Action="Default" /> -->
    <!-- 	CA1812: Avoid uninstantiated internal classes	An instance of an assembly-level type is not created by code in the assembly. -->
    <!-- <Rule Id="CA1812" Action="Default" /> -->
    <!-- 	CA1813: Avoid unsealed attributes	.NET provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance. -->
    <!-- <Rule Id="CA1813" Action="Default" /> -->
    <!-- 	CA1814: Prefer jagged arrays over multidimensional	A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data. -->
    <!-- <Rule Id="CA1814" Action="Default" /> -->
    <!-- 	CA1815: Override equals and operator equals on value types	For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals. -->
    <!-- <Rule Id="CA1815" Action="Default" /> -->
    <!-- 	CA1816: Call GC.SuppressFinalize correctly	A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic). -->
    <!-- <Rule Id="CA1816" Action="Default" /> -->
    <!-- 	CA1819: Properties should not return arrays	Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property. -->
    <!-- <Rule Id="CA1819" Action="Default" /> -->
    <!-- 	CA1820: Test for empty strings using string length	Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals. -->
    <!-- <Rule Id="CA1820" Action="Default" /> -->
    <!-- 	CA1821: Remove empty finalizers	Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime. An empty finalizer incurs added overhead and delivers no benefit. -->
    <!-- <Rule Id="CA1821" Action="Default" /> -->
    <!-- 	CA1822: Mark members as static	Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code. -->
    <!-- <Rule Id="CA1822" Action="Default" /> -->
    <!-- 	CA1823: Avoid unused private fields	Private fields were detected that do not appear to be accessed in the assembly. -->
    <!-- <Rule Id="CA1823" Action="Default" /> -->
    <!-- 	CA1824: Mark assemblies with NeutralResourcesLanguageAttribute	The NeutralResourcesLanguage attribute informs the resource manager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set. -->
    <!-- <Rule Id="CA1824" Action="Default" /> -->
    <!-- 	CA1900: Value type fields should be portable	This rule checks that structures that are declared by using explicit layout will align correctly when marshaled to unmanaged code on 64-bit operating systems. -->
    <!-- <Rule Id="CA1900" Action="Default" /> -->
    <!-- 	CA1901: P/Invoke declarations should be portable	This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems. -->
    <!-- <Rule Id="CA1901" Action="Default" /> -->
    <!-- 	CA1903: Use only API from targeted framework	A member or type is using a member or type that was introduced in a service pack that was not included together with the targeted framework of the project. -->
    <!-- <Rule Id="CA1903" Action="Default" /> -->
    <!-- 	CA2000: Dispose objects before losing scope	Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope. -->
    <!-- <Rule Id="CA2000" Action="Default" /> -->
    <!-- 	CA2001: Avoid calling problematic methods	A member calls a potentially dangerous or problematic method. -->
    <!-- <Rule Id="CA2001" Action="Default" /> -->
    <!-- 	CA2002: Do not lock on objects with weak identity	An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object. -->
    <!-- <Rule Id="CA2002" Action="Default" /> -->
    <!-- 	CA2003: Do not treat fibers as threads	A managed thread is being treated as a Win32 thread. -->
    <!-- <Rule Id="CA2003" Action="Default" /> -->
    <!-- 	CA2004: Remove calls to GC.KeepAlive	If you convert to SafeHandle usage, remove all calls to GC.KeepAlive (object). In this case, classes should not have to call GC.KeepAlive. This assumes they do not have a finalizer but rely on SafeHandle to finalize the OS handle for them. -->
    <!-- <Rule Id="CA2004" Action="Default" /> -->
    <!-- 	CA2006: Use SafeHandle to encapsulate native resources	Use of IntPtr in managed code might indicate a potential security and reliability problem. All uses of IntPtr must be reviewed to determine whether use of a SafeHandle, or similar technology, is required in its place. -->
    <!-- <Rule Id="CA2006" Action="Default" /> -->
    <!-- 	CA2007: Do not directly await a Task	An asynchronous method awaits a Task directly. When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. This behavior can be costly in terms of performance and can result in a deadlock on the UI thread. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. -->
    <Rule Id="CA2007" Action="None" />
    <!-- 	CA2100: Review SQL queries for security vulnerabilities	A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method. This rule assumes that the string argument contains user input. A SQL command string that is built from user input is vulnerable to SQL injection attacks. -->
    <!-- <Rule Id="CA2100" Action="Default" /> -->
    <!-- 	CA2101: Specify marshaling for P/Invoke string arguments	A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability. -->
    <!-- <Rule Id="CA2101" Action="Default" /> -->
    <!-- 	CA2102: Catch non-CLSCompliant exceptions in general handlers	A member in an assembly that is not marked by using the RuntimeCompatibilityAttribute or is marked RuntimeCompatibility(WrapNonExceptionThrows = false) contains a catch block that handles System.Exception and does not contain an immediately following general catch block. -->
    <!-- <Rule Id="CA2102" Action="Default" /> -->
    <!-- 	CA2103: Review imperative security	A method uses imperative security and might be constructing the permission by using state information or return values that can change as long as the demand is active. Use declarative security whenever possible. -->
    <!-- <Rule Id="CA2103" Action="Default" /> -->
    <!-- 	CA2104: Do not declare read only mutable reference types	An externally visible type contains an externally visible read-only field that is a mutable reference type. A mutable type is a type whose instance data can be modified. -->
    <!-- <Rule Id="CA2104" Action="Default" /> -->
    <!-- 	CA2105: Array fields should not be read only	When you apply the read-only (ReadOnly in Visual Basic) modifier to a field that contains an array, the field cannot be changed to reference a different array. However, the elements of the array that are stored in a read-only field can be changed. -->
    <!-- <Rule Id="CA2105" Action="Default" /> -->
    <!-- 	CA2106: Secure asserts	A method asserts a permission and no security checks are performed on the caller. Asserting a security permission without performing any security checks can leave an exploitable security weakness in your code. -->
    <!-- <Rule Id="CA2106" Action="Default" /> -->
    <!-- 	CA2107: Review deny and permit only usage	The PermitOnly method and CodeAccessPermission.Deny security actions should be used only by those who have an advanced knowledge of .NET security. Code that uses these security actions should undergo a security review. -->
    <!-- <Rule Id="CA2107" Action="Default" /> -->
    <!-- 	CA2108: Review declarative security on value types	A public or protected value type is secured by Data Access or Link Demands. -->
    <!-- <Rule Id="CA2108" Action="Default" /> -->
    <!-- 	CA2109: Review visible event handlers	A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary. -->
    <!-- <Rule Id="CA2109" Action="Default" /> -->
    <!-- 	CA2111: Pointers should not be visible	A pointer is not private, internal, or read-only. Malicious code can change the value of the pointer, which potentially gives access to arbitrary locations in memory or causes application or system failures. -->
    <!-- <Rule Id="CA2111" Action="Default" /> -->
    <!-- 	CA2112: Secured types should not expose fields	A public or protected type contains public fields and is secured by Link Demands. If code has access to an instance of a type that is secured by a link demand, the code does not have to satisfy the link demand to access the fields of the type. -->
    <!-- <Rule Id="CA2112" Action="Default" /> -->
    <!-- 	CA2114: Method security should be a superset of type	A method should not have both method-level and type-level declarative security for the same action. -->
    <!-- <Rule Id="CA2114" Action="Default" /> -->
    <!-- 	CA2115: Call GC.KeepAlive when using native resources	This rule detects errors that might occur because an unmanaged resource is being finalized while it is still being used in unmanaged code. -->
    <!-- <Rule Id="CA2115" Action="Default" /> -->
    <!-- 	CA2116: APTCA methods should only call APTCA methods	When the APTCA (AllowPartiallyTrustedCallersAttribute) is present on a fully trusted assembly, and the assembly executes code in another assembly that does not allow for partially trusted callers, a security exploit is possible. -->
    <!-- <Rule Id="CA2116" Action="Default" /> -->
    <!-- 	CA2117: APTCA types should only extend APTCA base types	When the APTCA is present on a fully trusted assembly, and a type in the assembly inherits from a type that does not allow for partially trusted callers, a security exploit is possible. -->
    <!-- <Rule Id="CA2117" Action="Default" /> -->
    <!-- 	CA2118: Review SuppressUnmanagedCodeSecurityAttribute usage	SuppressUnmanagedCodeSecurityAttribute changes the default security system behavior for members that execute unmanaged code that uses COM interop or operating system invocation. This attribute is primarily used to increase performance; however, the performance gains come together with significant security risks. -->
    <!-- <Rule Id="CA2118" Action="Default" /> -->
    <!-- 	CA2119: Seal methods that satisfy private interfaces	An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly. -->
    <!-- <Rule Id="CA2119" Action="Default" /> -->
    <!-- 	CA2120: Secure serialization constructors	This type has a constructor that takes a System.Runtime.Serialization.SerializationInfo object and a System.Runtime.Serialization.StreamingContext object (the signature of the serialization constructor). This constructor is not secured by a security check, but one or more of the regular constructors in the type are secured. -->
    <!-- <Rule Id="CA2120" Action="Default" /> -->
    <!-- 	CA2121: Static constructors should be private	The system calls the static constructor before the first instance of the type is created or any static members are referenced. If a static constructor is not private, it can be called by code other than the system. Depending on the operations that are performed in the constructor, this can cause unexpected behavior. -->
    <!-- <Rule Id="CA2121" Action="Default" /> -->
    <!-- 	CA2122: Do not indirectly expose methods with link demands	A public or protected member has Link Demands and is called by a member that does not perform any security checks. A link demand checks the permissions of the immediate caller only. -->
    <!-- <Rule Id="CA2122" Action="Default" /> -->
    <!-- 	CA2123: Override link demands should be identical to base	This rule matches a method to its base method, which is either an interface or a virtual method in another type, and then compares the link demands on each. If this rule is violated, a malicious caller can bypass the link demand just by calling the unsecured method. -->
    <!-- <Rule Id="CA2123" Action="Default" /> -->
    <!-- 	CA2124: Wrap vulnerable finally clauses in outer try	A public or protected method contains a try/finally block. The finally block appears to reset the security state and is not itself enclosed in a finally block. -->
    <!-- <Rule Id="CA2124" Action="Default" /> -->
    <!-- 	CA2126: Type link demands require inheritance demands	A public unsealed type is protected by using a link demand and has an overridable method. Neither the type nor the method is protected by using an inheritance demand. -->
    <!-- <Rule Id="CA2126" Action="Default" /> -->
    <!-- 	CA2136: Members should not have conflicting transparency annotations	Critical code cannot occur in a 100 percent-transparent assembly. This rule analyzes 100 percent-transparent assemblies for any SecurityCritical annotations at the type, field, and method levels. -->
    <!-- <Rule Id="CA2127" Action="Default" /> -->
    <!-- 	CA2147: Transparent methods may not use security asserts	This rule analyzes all methods and types in an assembly that is either 100 percent-transparent or mixed transparent/critical, and flags any declarative or imperative use of Assert. -->
    <!-- <Rule Id="CA2128" Action="Default" /> -->
    <!-- 	CA2140: Transparent code must not reference security critical items	Methods that are marked by SecurityTransparentAttribute call nonpublic members that are marked as SecurityCritical. This rule analyzes all methods and types in an assembly that is mixed transparent/critical, and flags any calls from transparent code to nonpublic critical code that are not marked as SecurityTreatAsSafe. -->
    <!-- <Rule Id="CA2129" Action="Default" /> -->
    <!-- 	CA2130: Security critical constants should be transparent	Transparency enforcement is not enforced for constant values because compilers inline constant values so that no lookup is required at run time. Constant fields should be security transparent so that code reviewers do not assume that transparent code cannot access the constant. -->
    <!-- <Rule Id="CA2130" Action="Default" /> -->
    <!-- 	CA2131: Security critical types may not participate in type equivalence	A type participates in type equivalence and either the type itself, or a member or field of the type, is marked by using the SecurityCriticalAttribute attribute. This rule occurs on any critical types or types that contain critical methods or fields that are participating in type equivalence. When the CLR detects such a type, it does not load it with a TypeLoadException at run time. Typically, this rule is raised only when users implement type equivalence manually instead of in by relying on tlbimp and the compilers to do the type equivalence. -->
    <!-- <Rule Id="CA2131" Action="Default" /> -->
    <!-- 	CA2132: Default constructors must be at least as critical as base type default constructors	Types and members that have the SecurityCriticalAttribute cannot be used by Silverlight application code. Security-critical types and members can be used only by trusted code in the .NET Framework for Silverlight class library. Because a public or protected construction in a derived class must have the same or greater transparency than its base class, a class in an application cannot be derived from a class marked as SecurityCritical. -->
    <!-- <Rule Id="CA2132" Action="Default" /> -->
    <!-- 	CA2133: Delegates must bind to methods with consistent transparency	This warning is raised on a method that binds a delegate that is marked by using the SecurityCriticalAttribute to a method that is transparent or that is marked by using the SecuritySafeCriticalAttribute. The warning also is raised on a method that binds a delegate that is transparent or safe-critical to a critical method. -->
    <!-- <Rule Id="CA2133" Action="Default" /> -->
    <!-- 	CA2134: Methods must keep consistent transparency when overriding base methods	This rule is raised when a method marked by using the SecurityCriticalAttribute overrides a method that is transparent or marked by using the SecuritySafeCriticalAttribute. The rule also is raised when a method that is transparent or marked by using the SecuritySafeCriticalAttribute overrides a method that is marked by using a SecurityCriticalAttribute. The rule is applied when overriding a virtual method or implementing an interface. -->
    <!-- <Rule Id="CA2134" Action="Default" /> -->
    <!-- 	CA2135: Level 2 assemblies should not contain LinkDemands	LinkDemands are deprecated in the level 2 security rule set. Instead of using LinkDemands to enforce security at JIT compilation time, mark the methods, types, and fields by using the SecurityCriticalAttribute attribute. -->
    <!-- <Rule Id="CA2135" Action="Default" /> -->
    <!-- 	CA2136: Members should not have conflicting transparency annotations	Transparency attributes are applied from code elements of larger scope to elements of smaller scope. The transparency attributes of code elements that have larger scope take precedence over transparency attributes of code elements that are contained in the first element. For example, a class that is marked by using the SecurityCriticalAttribute attribute cannot contain a method that is marked by using the SecuritySafeCriticalAttribute attribute. -->
    <!-- <Rule Id="CA2136" Action="Default" /> -->
    <!-- 	CA2137: Transparent methods must contain only verifiable IL	A method contains unverifiable code or returns a type by reference. This rule is raised on attempts by security transparent code to execute unverifiable microsoft intermediate language (MISL). However, the rule does not contain a full IL verifier, and instead uses heuristics to catch most violations of MSIL verification. -->
    <!-- <Rule Id="CA2137" Action="Default" /> -->
    <!-- 	CA2138: Transparent methods must not call methods with the SuppressUnmanagedCodeSecurity attribute	A security transparent method calls a method that is marked by using the SuppressUnmanagedCodeSecurityAttribute attribute. -->
    <!-- <Rule Id="CA2138" Action="Default" /> -->
    <!-- 	CA2139: Transparent methods may not use the HandleProcessCorruptingExceptions attribute	This rule is raised by any method that is transparent and attempts to handle a process corrupting exception by using the HandleProcessCorruptedStateExceptionsAttribute attribute. A process corrupting exception is a CLR version 4.0 exception classification of exceptions such as AccessViolationException. The HandleProcessCorruptedStateExceptionsAttribute attribute may be used only by security critical methods, and will be ignored if it is applied to a transparent method. -->
    <!-- <Rule Id="CA2139" Action="Default" /> -->
    <!-- 	CA2140: Transparent code must not reference security critical items	A code element that is marked by using the SecurityCriticalAttribute attribute is security critical. A transparent method cannot use a security critical element. If a transparent type attempts to use a security critical type, a TypeAccessException, MethodAccessException, or FieldAccessException is raised. -->
    <!-- <Rule Id="CA2140" Action="Default" /> -->
    <!-- 	CA2141:Transparent methods must not satisfy LinkDemands	A security transparent method calls a method in an assembly that is not marked by using the APTCA, or a security transparent method satisfies a LinkDemand for a type or a method. -->
    <!-- <Rule Id="CA2141" Action="Default" /> -->
    <!-- 	CA2142: Transparent code should not be protected with LinkDemands	This rule is raised on transparent methods that require LinkDemands to access them. Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions. -->
    <!-- <Rule Id="CA2142" Action="Default" /> -->
    <!-- 	CA2143: Transparent methods should not use security demands	Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions. Security transparent code should use full demands to make security decisions and safe-critical code should not rely on transparent code to have made the full demand. -->
    <!-- <Rule Id="CA2143" Action="Default" /> -->
    <!-- 	CA2144: Transparent code should not load assemblies from byte arrays	The security review for transparent code is not as complete as the security review for critical code because transparent code cannot perform security sensitive actions. Assemblies that are loaded from a byte array might not be noticed in transparent code, and that byte array might contain critical, or more important safe-critical code, that does have to be audited. -->
    <!-- <Rule Id="CA2144" Action="Default" /> -->
    <!-- 	CA2145: Transparent methods should not be decorated with the SuppressUnmanagedCodeSecurityAttribute	Methods that are decorated by the SuppressUnmanagedCodeSecurityAttribute attribute have an implicit LinkDemand put upon any method that calls it. This LinkDemand requires that the calling code be security critical. Marking the method that uses SuppressUnmanagedCodeSecurity by using the SecurityCriticalAttribute attribute makes this requirement more obvious for callers of the method. -->
    <!-- <Rule Id="CA2145" Action="Default" /> -->
    <!-- 	CA2146: Types must be at least as critical as their base types and interfaces	This rule is raised when a derived type has a security transparency attribute that is not as critical as its base type or implemented interface. Only critical types can derive from critical base types or implement critical interfaces, and only critical or safe-critical types can derive from safe-critical base types or implement safe-critical interfaces. -->
    <!-- <Rule Id="CA2146" Action="Default" /> -->
    <!-- 	CA2147: Transparent methods may not use security asserts	Code that is marked as SecurityTransparentAttribute is not granted sufficient permissions to assert. -->
    <!-- <Rule Id="CA2147" Action="Default" /> -->
    <!-- 	CA2149: Transparent methods must not call into native code	This rule is raised on any transparent method that calls directly into native code (for example, through a P/Invoke). Violations of this rule lead to a MethodAccessException in the level 2 transparency model and a full demand for UnmanagedCode in the level 1 transparency model. -->
    <!-- <Rule Id="CA2149" Action="Default" /> -->
    <!-- 	CA2151: Fields with critical types should be security critical	To use security critical types, the code that references the type must be either security critical or security safe critical. This is true even if the reference is indirect. Therefore, having a security transparent or security safe critical field is misleading because transparent code will still be unable to access the field. -->
    <!-- <Rule Id="CA2151" Action="Default" /> -->
    <!-- 	CA2200: Rethrow to preserve stack details	An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost. -->
    <!-- <Rule Id="CA2200" Action="Default" /> -->
    <!-- 	CA2201: Do not raise reserved exception types	This makes the original error difficult to detect and debug. -->
    <!-- <Rule Id="CA2201" Action="Default" /> -->
    <!-- 	CA2202: Do not dispose objects multiple times	A method implementation contains code paths that could cause multiple calls to System.IDisposable.Dispose or a Dispose equivalent (such as a Close() method on some types) on the same object. -->
    <!-- <Rule Id="CA2202" Action="Default" /> -->
    <!-- 	CA2204: Literals should be spelled correctly	A literal string in a method body contains one or more words that are not recognized by the Microsoft spelling checker library. -->
    <!-- <Rule Id="CA2204" Action="Default" /> -->
    <!-- 	CA2205: Use managed equivalents of Win32 API	An operating system invoke method is defined and a .NET method that has the equivalent functionality is available. -->
    <!-- <Rule Id="CA2205" Action="Default" /> -->
    <!-- 	CA2207: Initialize value type static fields inline	A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor. -->
    <!-- <Rule Id="CA2207" Action="Default" /> -->
    <!-- 	CA2208: Instantiate argument exceptions correctly	A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException. -->
    <!-- <Rule Id="CA2208" Action="Default" /> -->
    <!-- 	CA2210: Assemblies should have valid strong names	The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer. -->
    <!-- <Rule Id="CA2210" Action="Default" /> -->
    <!-- 	CA2211: Non-constant fields should not be visible	Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object. -->
    <!-- <Rule Id="CA2211" Action="Default" /> -->
    <!-- 	CA2212: Do not mark serviced components with WebMethod	A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked by using System.Web.Services.WebMethodAttribute. Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the behavior of the method will be incorrect in some scenarios. -->
    <!-- <Rule Id="CA2212" Action="Default" /> -->
    <!-- 	CA2213: Disposable fields should be disposed	A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. -->
    <!-- <Rule Id="CA2213" Action="Default" /> -->
    <!-- 	CA2214: Do not call overridable methods in constructors	When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed. -->
    <!-- <Rule Id="CA2214" Action="Default" /> -->
    <!-- 	CA2215: Dispose methods should call base class dispose	If a type inherits from a disposable type, it must call the Dispose method of the base type from its own Dispose method. -->
    <!-- <Rule Id="CA2215" Action="Default" /> -->
    <!-- 	CA2216: Disposable types should declare finalizer	A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize. -->
    <!-- <Rule Id="CA2216" Action="Default" /> -->
    <!-- 	CA2217: Do not mark enums with FlagsAttribute	An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration. -->
    <!-- <Rule Id="CA2217" Action="Default" /> -->
    <!-- 	CA2218: Override GetHashCode on overriding Equals	GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code. -->
    <!-- <Rule Id="CA2218" Action="Default" /> -->
    <!-- 	CA2219: Do not raise exceptions in exception clauses	When an exception is raised in a finally or fault clause, the new exception hides the active exception. When an exception is raised in a filter clause, the run time silently catches the exception. This makes the original error difficult to detect and debug. -->
    <!-- <Rule Id="CA2219" Action="Default" /> -->
    <!-- 	CA2220: Finalizers should call base class finalizer	Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method. -->
    <!-- <Rule Id="CA2220" Action="Default" /> -->
    <!-- 	CA2221: Finalizers should be protected	Finalizers must use the family access modifier. -->
    <!-- <Rule Id="CA2221" Action="Default" /> -->
    <!-- 	CA2222: Do not decrease inherited member visibility	You should not change the access modifier for inherited members. Changing an inherited member to private does not prevent callers from accessing the base class implementation of the method. -->
    <!-- <Rule Id="CA2222" Action="Default" /> -->
    <!-- 	CA2223: Members should differ by more than return type	Although the common language runtime allows the use of return types to differentiate between otherwise identical members, this feature is not in the Common Language Specification, nor is it a common feature of .NET programming languages. -->
    <!-- <Rule Id="CA2223" Action="Default" /> -->
    <!-- 	CA2224: Override equals on overloading operator equals	A public type implements the equality operator but does not override Object.Equals. -->
    <!-- <Rule Id="CA2224" Action="Default" /> -->
    <!-- 	CA2225: Operator overloads have named alternates	An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators. -->
    <!-- <Rule Id="CA2225" Action="Default" /> -->
    <!-- 	CA2226: Operators should have symmetrical overloads	A type implements the equality or inequality operator and does not implement the opposite operator. -->
    <!-- <Rule Id="CA2226" Action="Default" /> -->
    <!-- 	CA2227: Collection properties should be read only	A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set. -->
    <!-- <Rule Id="CA2227" Action="Default" /> -->
    <!-- 	CA2228: Do not ship unreleased resource formats	Resource files that were built by using prerelease versions of .NET might not be usable by supported versions of .NET. -->
    <!-- <Rule Id="CA2228" Action="Default" /> -->
    <!-- 	CA2229: Implement serialization constructors	To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected. -->
    <!-- <Rule Id="CA2229" Action="Default" /> -->
    <!-- 	CA2230: Use params for variable arguments	A public or protected type contains a public or protected method that uses the VarArgs calling convention instead of the params keyword. -->
    <!-- <Rule Id="CA2230" Action="Default" /> -->
    <!-- 	CA2231: Overload operator equals on overriding ValueType.Equals	A value type overrides Object.Equals but does not implement the equality operator. -->
    <!-- <Rule Id="CA2231" Action="Default" /> -->
    <!-- 	CA2232: Mark Windows Forms entry points with STAThread	STAThreadAttribute indicates that the COM threading model for the application is a single-threaded apartment. This attribute must be present on the entry point of any application that uses Windows Forms; if it is omitted, the Windows components might not work correctly. -->
    <!-- <Rule Id="CA2232" Action="Default" /> -->
    <!-- 	CA2233: Operations should not overflow	You should not perform arithmetic operations without first validating the operands. This makes sure that the result of the operation is not outside the range of possible values for the data types that are involved. -->
    <!-- <Rule Id="CA2233" Action="Default" /> -->
    <!-- 	CA2234: Pass System.Uri objects instead of strings	A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter. -->
    <!-- <Rule Id="CA2234" Action="Default" /> -->
    <!-- 	CA2235: Mark all non-serializable fields	An instance field of a type that is not serializable is declared in a type that is serializable. -->
    <!-- <Rule Id="CA2235" Action="Default" /> -->
    <!-- 	CA2236: Call base class methods on ISerializable types	To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type method or constructor. -->
    <!-- <Rule Id="CA2236" Action="Default" /> -->
    <!-- 	CA2237: Mark ISerializable types with SerializableAttribute	To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface. -->
    <!-- <Rule Id="CA2237" Action="Default" /> -->
    <!-- 	CA2238: Implement serialization methods correctly	A method that handles a serialization event does not have the correct signature, return type, or visibility. -->
    <!-- <Rule Id="CA2238" Action="Default" /> -->
    <!-- 	CA2239: Provide deserialization methods for optional fields	A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods. -->
    <!-- <Rule Id="CA2239" Action="Default" /> -->
    <!-- 	CA2240: Implement ISerializable correctly	To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute. -->
    <!-- <Rule Id="CA2240" Action="Default" /> -->
    <!-- 	CA2241: Provide correct arguments to formatting methods	The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa. -->
    <!-- <Rule Id="CA2241" Action="Default" /> -->
    <!-- 	CA2242: Test for NaN correctly	This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value. -->
    <!-- <Rule Id="CA2242" Action="Default" /> -->
    <!-- 	CA2243: Attribute string literals should parse correctly	The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version. -->
    <!-- <Rule Id="CA2243" Action="Default" /> -->
    <!-- 	CA5122 P/Invoke declarations should not  -->
    <!-- <Rule Id="CA5122" Action="Default" /> -->
  </Rules>

  <Rules AnalyzerId="Microsoft.NetCore.CSharp.Analyzers" RuleNamespace="Microsoft.NetCore.CSharp.Analyzers">
    <!--CA1309: Use ordinal StringComparison -->
    <!-- <Rule Id="CA1309" Action="Warning" /> -->
    <!--CA1414: Mark boolean PInvoke arguments with MarshalAs -->
    <!-- <Rule Id="CA1414" Action="Warning" /> -->
    <!--CA1601: Do not use timers that prevent power state changes -->
    <!-- <Rule Id="CA1601" Action="Warning" /> -->
    <!--CA1810: Initialize reference type static fields inline -->
    <!-- <Rule Id="CA1810" Action="Warning" /> -->
    <!--CA1824: Mark assemblies with NeutralResourcesLanguageAttribute -->
    <!-- <Rule Id="CA1824" Action="Warning" /> -->
    <!--CA1825: Avoid zero-length array allocations -->
    <Rule Id="CA1825" Action="None" />
    <!--CA2010: Always consume the value returned by methods marked with PreserveSigAttribute -->
    <!-- <Rule Id="CA2010" Action="Warning" /> -->
    <!--CA2201: Do not raise reserved exception types -->
    <!-- <Rule Id="CA2201" Action="Warning" /> -->
    <!--CA2205: Use managed equivalents of win32 api -->
    <!-- <Rule Id="CA2205" Action="Warning" /> -->
    <!-- CA2207: Initialize value type static fields inline -->
    <!-- <Rule Id="CA2207" Action="Warning" /> -->
    <!--CA2215: Dispose Methods Should Call Base Class Dispose -->
    <!-- <Rule Id="CA2215" Action="Warning" /> -->
    <!--CA5350: Do Not Use Weak Cryptographic Algorithms (TripleDES, SHA-1, RIPEMD160)-->
    <!-- <Rule Id="CA5350" Action="Warning" /> -->
    <!--CA5350: Do Not Use Broken Cryptographic Algorithms (MD5, DES, RC2)-->
    <!-- <Rule Id="CA5351" Action="Warning" /> -->
  </Rules>
  <Rules AnalyzerId="StyleCop.Analyzers" RuleNamespace="StyleCop.Analyzers">

	  <!-- DoNotPrefixLocalMembersWithThis	A call to an instance member of the local class or a base class is prefixed with 'this.', within a C# code file. -->
    <!-- <Rule Id="SX1101" Action="" /> -->
    	<!-- FieldNamesMustBeginWithUnderscore	A field name does not begin with an underscore. -->
    <!-- <Rule Id="SX1309" Action="" /> -->
    	<!-- StaticFieldNamesMustBeginWithUnderscore	A static field name does not begin with an underscore. -->
    <!-- <Rule Id="SX1309S" Action="" /> -->
    	<!-- ElementsMustBeDocumented	A C# code element is missing a documentation header. -->
    <!-- <Rule Id="SA1600" Action="" /> -->
    	<!-- PartialElementsMustBeDocumented	A C# partial element is missing a documentation header. -->
    <!-- <Rule Id="SA1601" Action="" /> -->
    	<!-- EnumerationItemsMustBeDocumented	An item within a C# enumeration is missing an Xml documentation header. -->
    <!-- <Rule Id="SA1602" Action="" /> -->
    	<!-- DocumentationMustContainValidXml	The Xml within a C# element's document header is badly formed. -->
    <!-- <Rule Id="SA1603" Action="" /> -->
    	<!-- ElementDocumentationMustHaveSummary	The Xml header documentation for a C# element is missing a <summary> tag. -->
    <!-- <Rule Id="SA1604" Action="" /> -->
    	<!-- PartialElementDocumentationMustHaveSummary	The <summary> or <content> tag within the documentation header for a C# code element is missing or empty. -->
    <!-- <Rule Id="SA1605" Action="" /> -->
    	<!-- ElementDocumentationMustHaveSummaryText	The <summary> tag within the documentation header for a C# code element is empty. -->
    <!-- <Rule Id="SA1606" Action="" /> -->
    	<!-- PartialElementDocumentationMustHaveSummaryText	The <summary> or <content> tag within the documentation header for a C# code element is empty. -->
    <!-- <Rule Id="SA1607" Action="" /> -->
    	<!-- ElementDocumentationMustNotHaveDefaultSummary	The <summary> tag within an element's Xml header documentation contains the default text generated by Visual Studio during the creation of the element. -->
    <!-- <Rule Id="SA1608" Action="" /> -->
    	<!-- PropertyDocumentationMustHaveValue	The Xml header documentation for a C# property does not contain a <value> tag. -->
    <!-- <Rule Id="SA1609" Action="" /> -->
    	<!-- PropertyDocumentationMustHaveValueText	The Xml header documentation for a C# property contains an empty <value> tag. -->
    <!-- <Rule Id="SA1610" Action="" /> -->
    	<!-- ElementParametersMustBeDocumented	A C# method, constructor, delegate or indexer element is missing documentation for one or more of its parameters. -->
    <!-- <Rule Id="SA1611" Action="" /> -->
    	<!-- ElementParameterDocumentationMustMatchElementParameters	The documentation describing the parameters to a C# method, constructor, delegate or indexer element does not match the actual parameters on the element. -->
    <!-- <Rule Id="SA1612" Action="" /> -->
    	<!-- ElementParameterDocumentationMustDeclareParameterName	A <param> tag within a C# element's documentation header is missing a name attribute containing the name of the parameter. -->
    <!-- <Rule Id="SA1613" Action="" /> -->
    	<!-- ElementParameterDocumentationMustHaveText	A <param> tag within a C# element's documentation header is empty. -->
    <!-- <Rule Id="SA1614" Action="" /> -->
    	<!-- ElementReturnValueMustBeDocumented	A C# element is missing documentation for its return value. -->
    <!-- <Rule Id="SA1615" Action="" /> -->
    	<!-- ElementReturnValueDocumentationMustHaveText	The <returns> tag within a C# element's documentation header is empty. -->
    <!-- <Rule Id="SA1616" Action="" /> -->
    	<!-- VoidReturnValueMustNotBeDocumented	A C# code element does not contain a return value, or returns void, but the documentation header for the element contains a <returns> tag. -->
    <!-- <Rule Id="SA1617" Action="" /> -->
    	<!-- GenericTypeParametersMustBeDocumented	A generic C# element is missing documentation for one or more of its generic type parameters. -->
    <!-- <Rule Id="SA1618" Action="" /> -->
    	<!-- GenericTypeParametersMustBeDocumentedPartialClass	A generic, partial C# element is missing documentation for one or more of its generic type parameters, and the documentation for the element contains a <summary> tag. -->
    <!-- <Rule Id="SA1619" Action="" /> -->
    	<!-- GenericTypeParameterDocumentationMustMatchTypeParameters	The <typeparam> tags within the Xml header documentation for a generic C# element do not match the generic type parameters on the element. -->
    <!-- <Rule Id="SA1620" Action="" /> -->
    	<!-- GenericTypeParameterDocumentationMustDeclareParameterName	A <typeparam> tag within the Xml header documentation for a generic C# element is missing a name attribute, or contains an empty name attribute. -->
    <!-- <Rule Id="SA1621" Action="" /> -->
    	<!-- GenericTypeParameterDocumentationMustHaveText	A <typeparam> tag within the Xml header documentation for a generic C# element is empty. -->
    <!-- <Rule Id="SA1622" Action="" /> -->
    	<!-- PropertySummaryDocumentationMustMatchAccessors	The documentation text within a C# property's <summary> tag does not match the accessors within the property. -->
    <!-- <Rule Id="SA1623" Action="" /> -->
    	<!-- PropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess	The documentation text within a C# property's <summary> tag takes into account all of the accessors within the property, but one of the accessors has limited access. -->
    <!-- <Rule Id="SA1624" Action="" /> -->
    	<!-- ElementDocumentationMustNotBeCopiedAndPasted	The Xml documentation for a C# element contains two or more identical entries, indicating that the documentation has been copied and pasted. -->
    <!-- <Rule Id="SA1625" Action="" /> -->
    	<!-- SingleLineCommentsMustNotUseDocumentationStyleSlashes	The C# code contains a single-line comment which begins with three forward slashes in a row. -->
    <!-- <Rule Id="SA1626" Action="" /> -->
    	<!-- DocumentationTextMustNotBeEmpty	The Xml header documentation for a C# code element contains an empty tag. -->
    <!-- <Rule Id="SA1627" Action="" /> -->
    	<!-- DocumentationTextMustBeginWithACapitalLetter	A section of the Xml header documentation for a C# element does not begin with a capital letter. -->
    <!-- <Rule Id="SA1628" Action="" /> -->
    	<!-- DocumentationTextMustEndWithAPeriod	A section of the Xml header documentation for a C# element does not end with a period (also known as a full stop). -->
    <!-- <Rule Id="SA1629" Action="" /> -->
    	<!-- DocumentationTextMustContainWhitespace	A section of the Xml header documentation for a C# element does not contain any whitespace between words. -->
    <!-- <Rule Id="SA1630" Action="" /> -->
    	<!-- DocumentationMustMeetCharacterPercentage	A section of the Xml header documentation for a C# element does not contain enough alphabetic characters. -->
    <!-- <Rule Id="SA1631" Action="" /> -->
    	<!-- DocumentationTextMustMeetMinimumCharacterLength	From StyleCop 4.5 this rule is disabled by default. -->
    <!-- <Rule Id="SA1632" Action="" /> -->
    	<!-- FileMustHaveHeader	A C# code file is missing a standard file header. -->
    <Rule Id="SA1633" Action="None" />
    	<!-- FileHeaderMustShowCopyright	The file header at the top of a C# code file is missing a copyright tag. -->
    <!-- <Rule Id="SA1634" Action="" /> -->
    	<!-- FileHeaderMustHaveCopyrightText	The file header at the top of a C# code file is missing copyright text. -->
    <!-- <Rule Id="SA1635" Action="" /> -->
    	<!-- FileHeaderCopyrightTextMustMatch	The file header at the top of a C# code file does not contain the appropriate copyright text. -->
    <!-- <Rule Id="SA1636" Action="" /> -->
    	<!-- FileHeaderMustContainFileName	The file header at the top of a C# code file is missing the file name. -->
    <!-- <Rule Id="SA1637" Action="" /> -->
    	<!-- FileHeaderFileNameDocumentationMustMatchFileName	The file tag within the file header at the top of a C# code file does not contain the name of the file. -->
    <!-- <Rule Id="SA1638" Action="" /> -->
    	<!-- FileHeaderMustHaveSummary	The file header at the top of a C# code file does not contain a filled-in summary tag. -->
    <!-- <Rule Id="SA1639" Action="" /> -->
    	<!-- FileHeaderMustHaveValidCompanyText	The file header at the top of a C# code file does not contain company name text. -->
    <!-- <Rule Id="SA1640" Action="" /> -->
    	<!-- FileHeaderCompanyNameTextMustMatch	The file header at the top of a C# code file does not contain the appropriate company name text. -->
    <!-- <Rule Id="SA1641" Action="" /> -->
    	<!-- ConstructorSummaryDocumentationMustBeginWithStandardText	The XML documentation header for a C# constructor does not contain the appropriate summary text. -->
    <!-- <Rule Id="SA1642" Action="" /> -->
    	<!-- DestructorSummaryDocumentationMustBeginWithStandardText	The Xml documentation header for a C# finalizer does not contain the appropriate summary text. -->
    <!-- <Rule Id="SA1643" Action="" /> -->
    	<!-- DocumentationHeadersMustNotContainBlankLines	A section within the Xml documentation header for a C# element contains blank lines. -->
    <!-- <Rule Id="SA1644" Action="" /> -->
    	<!-- IncludedDocumentationFileDoesNotExist	An included Xml documentation file does not exist. -->
    <!-- <Rule Id="SA1645" Action="" /> -->
    	<!-- IncludedDocumentationXPathDoesNotExist	An included Xml documentation link contains an invalid path. -->
    <!-- <Rule Id="SA1646" Action="" /> -->
    	<!-- IncludeNodeDoesNotContainValidFileAndPath	An include tag within an Xml documentation header does not contain valid file and path attribute. -->
    <!-- <Rule Id="SA1647" Action="" /> -->
    	<!-- InheritDocMustBeUsedWithInheritingClass	<inheritdoc> has been used on an element that doesn't inherit from a base class or implement an interface. -->
    <!-- <Rule Id="SA1648" Action="" /> -->
    	<!-- FileNameMustMatchTypeName	The file name of a C# code file does not match the first type declared in the file. -->
    <Rule Id="SA1649" Action="None" />
    	<!-- ElementDocumentationMustBeSpelledCorrectly	The element documentation for the element contains one or more spelling mistakes or unrecognized words. -->
    <!-- <Rule Id="SA1650" Action="" /> -->
    	<!-- DoNotUsePlaceholderElements	The documentation for the element contains one or more <placeholder> elements. -->
    <!-- <Rule Id="SA1651" Action="" /> -->
    	<!-- EnableXmlDocumentationOutput -->
    <!-- <Rule Id="SA1652" Action="" /> -->
    	<!-- BracesForMultiLineStatementsMustNotShareLine	The opening or closing brace within a C# statement, element, or expression is not placed on its own line. -->
    <!-- <Rule Id="SA1500" Action="" /> -->
    	<!-- StatementMustNotBeOnSingleLine	A C# statement containing opening and closing braces is written completely on a single line. -->
    <!-- <Rule Id="SA1501" Action="" /> -->
    	<!-- ElementMustNotBeOnSingleLine	A C# element containing opening and closing braces is written completely on a single line. -->
    <!-- <Rule Id="SA1502" Action="" /> -->
    	<!-- BracesMustNotBeOmitted	The opening and closing braces for a C# statement have been omitted. -->
    <!-- <Rule Id="SA1503" Action="" /> -->
    	<!-- AllAccessorsMustBeSingleLineOrMultiLine	Within a C# property, indexer or event, at least one of the child accessors is written on a single line, and at least one of the child accessors is written across multiple lines. -->
    <!-- <Rule Id="SA1504" Action="" /> -->
    	<!-- OpeningBracesMustNotBeFollowedByBlankLine	An opening brace within a C# element, statement, or expression is followed by a blank line. -->
    <!-- <Rule Id="SA1505" Action="" /> -->
    	<!-- ElementDocumentationHeadersMustNotBeFollowedByBlankLine	An element documentation header above a C# element is followed by a blank line. -->
    <!-- <Rule Id="SA1506" Action="" /> -->
    	<!-- CodeMustNotContainMultipleBlankLinesInARow	The C# code contains multiple blank lines in a row. -->
    <!-- <Rule Id="SA1507" Action="" /> -->
    	<!-- ClosingBracesMustNotBePrecededByBlankLine	A closing brace within a C# element, statement, or expression is preceded by a blank line. -->
    <!-- <Rule Id="SA1508" Action="" /> -->
    	<!-- OpeningBracesMustNotBePrecededByBlankLine	An opening brace within a C# element, statement, or expression is preceded by a blank line. -->
    <!-- <Rule Id="SA1509" Action="" /> -->
    	<!-- ChainedStatementBlocksMustNotBePrecededByBlankLine	Chained C# statements are separated by a blank line. -->
    <!-- <Rule Id="SA1510" Action="" /> -->
    	<!-- WhileDoFooterMustNotBePrecededByBlankLine	The while footer at the bottom of a do-while statement is separated from the statement by a blank line. -->
    <!-- <Rule Id="SA1511" Action="" /> -->
    	<!-- SingleLineCommentsMustNotBeFollowedByBlankLine	A single-line comment within C# code is followed by a blank line. -->
    <!-- <Rule Id="SA1512" Action="" /> -->
    	<!-- ClosingBraceMustBeFollowedByBlankLine	A closing brace within a C# element, statement, or expression is not followed by a blank line. -->
    <!-- <Rule Id="SA1513" Action="" /> -->
    	<!-- ElementDocumentationHeaderMustBePrecededByBlankLine	An element documentation header above a C# element is not preceded by a blank line. -->
    <!-- <Rule Id="SA1514" Action="" /> -->
    	<!-- SingleLineCommentMustBePrecededByBlankLine	A single-line comment within C# code is not preceded by a blank line. -->
    <!-- <Rule Id="SA1515" Action="" /> -->
    	<!-- ElementsMustBeSeparatedByBlankLine	Adjacent C# elements are not separated by a blank line. -->
    <!-- <Rule Id="SA1516" Action="" /> -->
    	<!-- CodeMustNotContainBlankLinesAtStartOfFile	The code file has blank lines at the start. -->
    <!-- <Rule Id="SA1517" Action="" /> -->
    	<!-- UseLineEndingsCorrectlyAtEndOfFile	The line endings at the end of a file do not match the settings for the project. -->
    <!-- <Rule Id="SA1518" Action="" /> -->
    	<!-- BracesMustNotBeOmittedFromMultiLineChildStatement	The opening and closing braces for a multi-line C# statement have been omitted. -->
    <!-- <Rule Id="SA1519" Action="" /> -->
    	<!-- UseBracesConsistently	The opening and closing braces of a chained if/else if/else construct were included for some clauses, but omitted for others. -->
    <!-- <Rule Id="SA1520" Action="" /> -->
    	<!-- StatementMustNotUseUnnecessaryParenthesis	A C# statement contains parenthesis which are unnecessary and should be removed. -->
    <!-- <Rule Id="SA1119" Action="" /> -->
    	<!-- AccessModifierMustBeDeclared	The access modifier for a C# element has not been explicitly defined. -->
    <!-- <Rule Id="SA1400" Action="" /> -->
    	<!-- FieldsMustBePrivate	A field within a C# class has an access modifier other than private. -->
    <!-- <Rule Id="SA1401" Action="" /> -->
    	<!-- FileMayOnlyContainASingleType	A C# code file contains more than one unique type. -->
    <Rule Id="SA1402" Action="None" />
    	<!-- FileMayOnlyContainASingleNamespace	A C# code file contains more than one namespace. -->
    <!-- <Rule Id="SA1403" Action="" /> -->
    	<!-- CodeAnalysisSuppressionMustHaveJustification	A Code Analysis SuppressMessage attribute does not include a justification. -->
    <!-- <Rule Id="SA1404" Action="" /> -->
    	<!-- DebugAssertMustProvideMessageText	A call to Debug.Assert in C# code does not include a descriptive message. -->
    <!-- <Rule Id="SA1405" Action="" /> -->
    	<!-- DebugFailMustProvideMessageText	A call to Debug.Fail in C# code does not include a descriptive message. -->
    <!-- <Rule Id="SA1406" Action="" /> -->
    	<!-- ArithmeticExpressionsMustDeclarePrecedence	A C# statement contains a complex arithmetic expression which omits parenthesis around operators. -->
    <!-- <Rule Id="SA1407" Action="" /> -->
    	<!-- ConditionalExpressionsMustDeclarePrecedence	A C# statement contains a complex conditional expression which omits parenthesis around operators. -->
    <!-- <Rule Id="SA1408" Action="" /> -->
    	<!-- RemoveUnnecessaryCode	A C# file contains code which is unnecessary and can be removed without changing the overall logic of the code. -->
    <!-- <Rule Id="SA1409" Action="" /> -->
    	<!-- RemoveDelegateParenthesisWhenPossible	A call to a C# anonymous method does not contain any method parameters, yet the statement still includes parenthesis. -->
    <!-- <Rule Id="SA1410" Action="" /> -->
    	<!-- AttributeConstructorMustNotUseUnnecessaryParenthesis	An attribute declaration does not contain any parameters, yet it still includes parenthesis. -->
    <!-- <Rule Id="SA1411" Action="" /> -->
    	<!-- StoreFilesAsUtf8	The encoding of the file is not UTF-8 with byte order mark. -->
    <!-- <Rule Id="SA1412" Action="" /> -->
    	<!-- UseTrailingCommasInMultiLineInitializers	A multi-line initializer should use a comma on the last item. -->
    <!-- <Rule Id="SA1413" Action="" /> -->
    	<!-- TupleTypesInSignaturesShouldHaveElementNames	Tuple types appearing in member declarations should have explicitly named tuple elements. -->
    <!-- <Rule Id="SA1414" Action="" /> -->
    	<!-- ElementMustBeginWithUpperCaseLetter	The name of a C# element does not begin with an upper-case letter. -->
    <!-- <Rule Id="SA1300" Action="" /> -->
    	<!-- ElementMustBeginWithLowerCaseLetter	There are currently no situations in which this rule will fire. -->
    <!-- <Rule Id="SA1301" Action="" /> -->
    	<!-- InterfaceNamesMustBeginWithI	The name of a C# interface does not begin with the capital letter I. -->
    <!-- <Rule Id="SA1302" Action="" /> -->
    	<!-- ConstFieldNamesMustBeginWithUpperCaseLetter	The name of a constant C# field should begin with an upper-case letter. -->
    <!-- <Rule Id="SA1303" Action="" /> -->
    	<!-- NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter	The name of a non-private readonly C# field should being with an upper-case letter. -->
    <!-- <Rule Id="SA1304" Action="" /> -->
    	<!-- FieldNamesMustNotUseHungarianNotation	The name of a field or variable in C# uses Hungarian notation. -->
    <!-- <Rule Id="SA1305" Action="" /> -->
    	<!-- FieldNamesMustBeginWithLowerCaseLetter	The name of a field in C# does not begin with a lower-case letter. -->
    <!-- <Rule Id="SA1306" Action="" /> -->
    	<!-- AccessibleFieldsMustBeginWithUpperCaseLetter	The name of a public or internal field in C# does not begin with an upper-case letter. -->
    <!-- <Rule Id="SA1307" Action="" /> -->
    	<!-- VariableNamesMustNotBePrefixed	A field name in C# is prefixed with m_ or s_. -->
    <!-- <Rule Id="SA1308" Action="" /> -->
    	<!-- FieldNamesMustNotBeginWithUnderscore	A field name in C# begins with an underscore. -->
    <!-- <Rule Id="SA1309" Action="" /> -->
    	<!-- FieldNamesMustNotContainUnderscore	A field name in C# contains an underscore. -->
    <!-- <Rule Id="SA1310" Action="" /> -->
    	<!-- StaticReadonlyFieldsMustBeginWithUpperCaseLetter	The name of a static readonly field does not begin with an upper-case letter. -->
    <!-- <Rule Id="SA1311" Action="" /> -->
    	<!-- VariableNamesMustBeginWithLowerCaseLetter	The name of a variable in C# does not begin with a lower-case letter. -->
    <!-- <Rule Id="SA1312" Action="" /> -->
    	<!-- ParameterNamesMustBeginWithLowerCaseLetter	The name of a parameter in C# does not begin with a lower-case letter. -->
    <!-- <Rule Id="SA1313" Action="" /> -->
    	<!-- TypeParameterNamesMustBeginWithT	The name of a C# type parameter does not begin with the capital letter T. -->
    <!-- <Rule Id="SA1314" Action="" /> -->
    	<!-- TupleElementNamesShouldUseCorrectCasing	Element names within a tuple type should have the correct casing. -->
    <!-- <Rule Id="SA1316" Action="" /> -->
    	<!-- UsingDirectivesMustBePlacedCorrectly	A C# using directive is placed outside of a namespace element. -->
    <!-- <Rule Id="SA1200" Action="" /> -->
    	<!-- ElementsMustAppearInTheCorrectOrder	An element within a C# code file is out of order in relation to the other elements in the code. -->
    <Rule Id="SA1201" Action="None" />
    	<!-- ElementsMustBeOrderedByAccess	An element within a C# code file is out of order within regard to access level, in relation to other elements in the code. -->
    <!-- <Rule Id="SA1202" Action="" /> -->
    	<!-- ConstantsMustAppearBeforeFields	A constant field is placed beneath a non-constant field. -->
    <!-- <Rule Id="SA1203" Action="" /> -->
    	<!-- StaticElementsMustAppearBeforeInstanceElements	A static element is positioned beneath an instance element of the same type. -->
    <!-- <Rule Id="SA1204" Action="" /> -->
    	<!-- PartialElementsMustDeclareAccess	The partial element does not have an access modifier defined. -->
    <!-- <Rule Id="SA1205" Action="" /> -->
    	<!-- DeclarationKeywordsMustFollowOrder	The keywords within the declaration of an element do not follow a standard ordering scheme. -->
    <!-- <Rule Id="SA1206" Action="" /> -->
    	<!-- ProtectedMustComeBeforeInternal	The keyword protected is positioned after the keyword internal within the declaration of a protected internal C# element. -->
    <!-- <Rule Id="SA1207" Action="" /> -->
    	<!-- SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives	A using directive which declares a member of the System namespace appears after a using directive which declares a member of a different namespace, within a C# code file. -->
    <!-- <Rule Id="SA1208" Action="" /> -->
    	<!-- UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives	A using-alias directive is positioned before a regular using directive. -->
    <!-- <Rule Id="SA1209" Action="" /> -->
    	<!-- UsingDirectivesMustBeOrderedAlphabeticallyByNamespace	The using directives within a C# code file are not sorted alphabetically by namespace. -->
    <!-- <Rule Id="SA1210" Action="" /> -->
    	<!-- UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName	The using-alias directives within a C# code file are not sorted alphabetically by alias name. -->
    <!-- <Rule Id="SA1211" Action="" /> -->
    	<!-- PropertyAccessorsMustFollowOrder	A get accessor appears after a set accessor within a property or indexer. -->
    <!-- <Rule Id="SA1212" Action="" /> -->
    	<!-- EventAccessorsMustFollowOrder	An add accessor appears after a remove accessor within an event. -->
    <!-- <Rule Id="SA1213" Action="" /> -->
    	<!-- ReadonlyElementsMustAppearBeforeNonReadonlyElements	A readonly field is positioned beneath a non-readonly field. -->
    <!-- <Rule Id="SA1214" Action="" /> -->
    	<!-- InstanceReadonlyElementsMustAppearBeforeInstanceNonReadonlyElements	An instance readonly element is positioned beneath an instance non-readonly element of the same type. -->
    <!-- <Rule Id="SA1215" Action="" /> -->
    	<!-- UsingStaticDirectivesMustBePlacedAtTheCorrectLocation	A using static directive is positioned at the wrong location (before a regular using directive or after an alias using directive). -->
    <!-- <Rule Id="SA1216" Action="" /> -->
    	<!-- UsingStaticDirectivesMustBeOrderedAlphabetically	The using static directives within a C# code file are not sorted alphabetically by full type name. -->
    <!-- <Rule Id="SA1217" Action="" /> -->
    	<!-- DoNotPrefixCallsWithBaseUnlessLocalImplementationExists	A call to a member from an inherited class begins with base., and the local class does not contain an override or implementation of the member. -->
    <!-- <Rule Id="SA1100" Action="" /> -->
    	<!-- PrefixLocalCallsWithThis	A call to an instance member of the local class or a base class is not prefixed with 'this.', within a C# code file. -->
    <Rule Id="SA1101" Action="None" />
    	<!-- QueryClauses	A C# query clause does not begin on the same line as the previous clause, or on the next line. -->
    <!-- <Rule Id="SA1102" Action="" /> -->
    	<!-- QueryClauses	The clauses within a C# query expression are not all placed on the same line, and each clause is not placed on its own line. -->
    <!-- <Rule Id="SA1103" Action="" /> -->
    	<!-- QueryClauses	A clause within a C# query expression begins on the same line as the previous clause, when the previous clause spans across multiple lines. -->
    <!-- <Rule Id="SA1104" Action="" /> -->
    	<!-- QueryClauses	A clause within a C# query expression spans across multiple lines, and does not begin on its own line. -->
    <!-- <Rule Id="SA1105" Action="" /> -->
    	<!-- CodeMustNotContainEmptyStatements	The C# code contains an extra semicolon. -->
    <!-- <Rule Id="SA1106" Action="" /> -->
    	<!-- CodeMustNotContainMultipleStatementsOnOneLine	The C# code contains more than one statement on a single line. -->
    <!-- <Rule Id="SA1107" Action="" /> -->
    	<!-- BlockStatementsMustNotContainEmbeddedComments	A C# statement contains a comment between the declaration of the statement and the opening brace of the statement. -->
    <!-- <Rule Id="SA1108" Action="" /> -->
    	<!-- BlockStatementsMustNotContainEmbeddedRegions	A C# statement contains a region tag between the declaration of the statement and the opening brace of the statement. -->
    <!-- <Rule Id="SA1109" Action="" /> -->
    	<!-- OpeningParenthesisMustBeOnDeclarationLine	The opening parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the method or indexer name. -->
    <!-- <Rule Id="SA1110" Action="" /> -->
    	<!-- ClosingParenthesisMustBeOnLineOfLastParameter	The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the last parameter. -->
    <!-- <Rule Id="SA1111" Action="" /> -->
    	<!-- ClosingParenthesisMustBeOnLineOfOpeningParenthesis	The closing parenthesis or bracket in a call to a C# method or indexer, or the declaration of a method or indexer, is not placed on the same line as the opening bracket when the element does not take any parameters. -->
    <!-- <Rule Id="SA1112" Action="" /> -->
    	<!-- CommaMustBeOnSameLineAsPreviousParameter	A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or indexer, is not placed on the same line as the previous parameter. -->
    <!-- <Rule Id="SA1113" Action="" /> -->
    	<!-- ParameterListMustFollowDeclaration	The start of the parameter list for a method or indexer call or declaration does not begin on the same line as the opening bracket, or on the line after the opening bracket. -->
    <!-- <Rule Id="SA1114" Action="" /> -->
    	<!-- ParameterMustFollowComma	A parameter within a C# method or indexer call or declaration does not begin on the same line as the previous parameter, or on the next line. -->
    <!-- <Rule Id="SA1115" Action="" /> -->
    	<!-- SplitParametersMustStartOnLineAfterDeclaration	The parameters to a C# method or indexer call or declaration span across multiple lines, but the first parameter does not start on the line after the opening bracket. -->
    <!-- <Rule Id="SA1116" Action="" /> -->
    	<!-- ParametersMustBeOnSameLineOrSeparateLines	The parameters to a C# method or indexer call or declaration are not all on the same line or each on a separate line. -->
    <!-- <Rule Id="SA1117" Action="" /> -->
    	<!-- ParameterMustNotSpanMultipleLines	A parameter to a C# method or indexer, other than the first parameter, spans across multiple lines. -->
    <!-- <Rule Id="SA1118" Action="" /> -->
    	<!-- CommentsMustContainText	The C# comment does not contain any comment text. -->
    <!-- <Rule Id="SA1120" Action="" /> -->
    	<!-- UseBuiltInTypeAlias	The code uses one of the basic C# types, but does not use the built-in alias for the type. -->
    <!-- <Rule Id="SA1121" Action="" /> -->
    	<!-- UseStringEmptyForEmptyStrings	The C# code includes an empty string, written as "". -->
    <!-- <Rule Id="SA1122" Action="" /> -->
    	<!-- DoNotPlaceRegionsWithinElements	The C# code contains a region within the body of a code element. -->
    <!-- <Rule Id="SA1123" Action="" /> -->
    	<!-- DoNotUseRegions	The C# code contains a region. -->
    <!-- <Rule Id="SA1124" Action="" /> -->
    	<!-- UseShorthandForNullableTypes	The Nullable type has been defined not using the C# shorthand. -->
    <!-- <Rule Id="SA1125" Action="" /> -->
    	<!-- PrefixCallsCorrectly	A call to a member is not prefixed with the 'this.', 'base.', 'object.' or 'typename.' prefix to indicate the intended method call, within a C# code file. -->
    <!-- <Rule Id="SA1126" Action="" /> -->
    	<!-- GenericTypeConstraintsMustBeOnOwnLine	A generic constraint on a type or method declaration is on the same line as the declaration, within a C# code file. -->
    <!-- <Rule Id="SA1127" Action="" /> -->
    	<!-- ConstructorInitializerMustBeOnOwnLine	A constructor initializer is on the same line as the constructor declaration, within a C# code file. -->
    <!-- <Rule Id="SA1128" Action="" /> -->
    	<!-- DoNotUseDefaultValueTypeConstructor	A value type was constructed using the syntax new T(). -->
    <!-- <Rule Id="SA1129" Action="" /> -->
    	<!-- UseLambdaSyntax	An anonymous method was declared using the form delegate (parameters) { }, when a lambda expression would provide equivalent behavior with the syntax (parameters) => { }. -->
    <!-- <Rule Id="SA1130" Action="" /> -->
    	<!-- UseReadableConditions	A comparison was made between a variable and a literal or constant value, and the variable appeared on the right-hand side of the expression. -->
    <!-- <Rule Id="SA1131" Action="" /> -->
    	<!-- DoNotCombineFields	Two or more fields were declared in the same field declaration syntax. -->
    <!-- <Rule Id="SA1132" Action="" /> -->
    	<!-- DoNotCombineAttributes	Two or more attributes appeared within the same set of square brackets. -->
    <!-- <Rule Id="SA1133" Action="" /> -->
    	<!-- AttributesMustNotShareLine	An attribute is placed on the same line of code as another attribute or element. -->
    <!-- <Rule Id="SA1134" Action="" /> -->
    	<!-- UsingDirectivesMustBeQualified	A using directive is not qualified. -->
    <!-- <Rule Id="SA1135" Action="" /> -->
    	<!-- EnumValuesShouldBeOnSeparateLines	Multiple enum values are placed on the same line of code. -->
    <!-- <Rule Id="SA1136" Action="" /> -->
    	<!-- ElementsShouldHaveTheSameIndentation	Two sibling elements which each start on their own line have different levels of indentation. -->
    <!-- <Rule Id="SA1137" Action="" /> -->
    	<!-- UseLiteralsSuffixNotationInsteadOfCasting	Use literal suffix notation instead of casting. -->
    <!-- <Rule Id="SA1139" Action="" /> -->
    	<!-- UseTupleSyntax	Use tuple syntax instead of the underlying ValueTuple implementation type. -->
    <!-- <Rule Id="SA1141" Action="" /> -->
    	<!-- ReferToTupleElementsByName	An element of a tuple was referenced by its metadata name when an element name is available. -->
    <!-- <Rule Id="SA1142" Action="" /> -->
    <!-- KeywordsMustBeSpacedCorrectly	The spacing around a C# keyword is incorrect. -->
    <!-- <Rule Id="SA1000" Action="" /> -->
    <!-- CommasMustBeSpacedCorrectly	The spacing around a comma is incorrect, within a C# code file. -->
    <!-- <Rule Id="SA1001" Action="" /> -->
    <!-- SemicolonsMustBeSpacedCorrectly	The spacing around a semicolon is incorrect, within a C# code file. -->
    <!-- <Rule Id="SA1002" Action="" /> -->
    <!-- SymbolsMustBeSpacedCorrectly	The spacing around an operator symbol is incorrect, within a C# code file. -->
    <!-- <Rule Id="SA1003" Action="" /> -->
    <!-- DocumentationLinesMustBeginWithSingleSpace	A line within a documentation header above a C# element does not begin with a single space. -->
    <!-- <Rule Id="SA1004" Action="" /> -->
    <!-- SingleLineCommentsMustBeginWithSingleSpace	A single-line comment within a C# code file does not begin with a single space. -->
    <!-- <Rule Id="SA1005" Action="" /> -->
    <!-- PreprocessorKeywordsMustNotBePrecededBySpace	A C# preprocessor-type keyword is preceded by space. -->
    <!-- <Rule Id="SA1006" Action="" /> -->
    <!-- OperatorKeywordMustBeFollowedBySpace	The operator keyword within a C# operator overload method is not followed by any whitespace. -->
    <!-- <Rule Id="SA1007" Action="" /> -->
    <!-- OpeningParenthesisMustBeSpacedCorrectly	An opening parenthesis within a C# statement is not spaced correctly. -->
    <!-- <Rule Id="SA1008" Action="" /> -->
    <!-- ClosingParenthesisMustBeSpacedCorrectly	A closing parenthesis within a C# statement is not spaced correctly. -->
    <!-- <Rule Id="SA1009" Action="" /> -->
    <!-- OpeningSquareBracketsMustBeSpacedCorrectly	An opening square bracket within a C# statement is not spaced correctly. -->
    <!-- <Rule Id="SA1010" Action="" /> -->
    <!-- ClosingSquareBracketsMustBeSpacedCorrectly	A closing square bracket within a C# statement is not spaced correctly. -->
    <!-- <Rule Id="SA1011" Action="" /> -->
    <!-- OpeningBracesMustBeSpacedCorrectly	An opening brace within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1012" Action="" /> -->
    <!-- ClosingBracesMustBeSpacedCorrectly	A closing brace within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1013" Action="" /> -->
    <!-- OpeningGenericBracketsMustBeSpacedCorrectly	An opening generic bracket within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1014" Action="" /> -->
    <!-- ClosingGenericBracketsMustBeSpacedCorrectly	A closing generic bracket within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1015" Action="" /> -->
    <!-- OpeningAttributeBracketsMustBeSpacedCorrectly	An opening attribute bracket within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1016" Action="" /> -->
    <!-- ClosingAttributeBracketsMustBeSpacedCorrectly	A closing attribute bracket within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1017" Action="" /> -->
    <!-- NullableTypeSymbolsMustNotBePrecededBySpace	A nullable type symbol within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1018" Action="" /> -->
    <!-- MemberAccessSymbolsMustBeSpacedCorrectly	The spacing around a member access symbol is incorrect, within a C# code file. -->
    <!-- <Rule Id="SA1019" Action="" /> -->
    <!-- IncrementDecrementSymbolsMustBeSpacedCorrectly	An increment or decrement symbol within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1020" Action="" /> -->
    <!-- NegativeSignsMustBeSpacedCorrectly	A negative sign within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1021" Action="" /> -->
    <!-- PositiveSignsMustBeSpacedCorrectly	A positive sign within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1022" Action="" /> -->
    <!-- DereferenceAndAccessOfMustBeSpacedCorrectly	A dereference symbol or an access-of symbol within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1023" Action="" /> -->
    <!-- ColonsMustBeSpacedCorrectly	A colon within a C# element is not spaced correctly. -->
    <!-- <Rule Id="SA1024" Action="" /> -->
    <!-- CodeMustNotContainMultipleWhitespaceInARow	The code contains multiple whitespace characters in a row. -->
    <!-- <Rule Id="SA1025" Action="None" /> -->
    <!-- CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation	An implicitly typed new array allocation within a C# code file is not spaced correctly. -->
    <!-- <Rule Id="SA1026" Action="" /> -->
    <!-- UseTabsCorrectly	The code contains a tab or space character which is not consistent with the current project settings. -->
    <!-- <Rule Id="SA1027" Action="" /> -->
    <!-- CodeMustNotContainTrailingWhitespace	A line of code ends with a space, tab, or other whitespace characters before the end of line character(s). -->
    <!-- <Rule Id="SA1028" Action="" /> -->
    <!-- XmlCommentAnalysisDisabled	All diagnostics of XML documentation comments has been disabled due to the current project configuration. -->
    <Rule Id="SA0001" Action="None" />
    <!-- InvalidSettingsFile	The stylecop.json settings file could not be loaded due to a deserialization error. -->
    <!-- <Rule Id="SA0002" Action="" /> -->

  </Rules>
</RuleSet>
